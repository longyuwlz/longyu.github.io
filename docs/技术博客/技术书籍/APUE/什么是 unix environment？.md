# 什么是 unix environment？
## unix 环境的概述
环境是一个相对**大范围**的概念，**unix** 环境对该概念的作用范围进行了限定，尽管如此这个概念涉及的东西仍然十分庞大。

从**内核到系统调用**到 **shell** 与系统库，这些都是环境的一部分。应用程序依赖于这些环境来完成**创建、执行、销毁**的全过程。这一过程的每一部分都相当复杂，具体的细节可以根据个人兴趣进行深入研究，但总体的架构却需要尽早的建立。

## 登入 unix 系统后的控制环境
登入 **unix** 系统时，系统通过读取系统数据文件 **/etc/passwd**  (密码文件)来为我们准备登入的环境。通过校验 **/etc/shadow** 中存储的加密密码，来验证用户的身份。校验成功后，结合 **/etc/group** 文件来创建必要的进程提供服务，最后我们将看到一个图形界面或者 **shell** 命令行，这是控制系统的主要途径。

## 文件权限的严格控制
**unix** 环境中，磁盘中存储的每一个目录或文件都由**三组不同权限**控制。同时每一个目录或文件拥有自己的**属主及属组**。

属主是文件的**拥有者**，属组则控制了**相同组中其它组员对共享资源的操作**。

 **unix** 环境提供了对文件目录权限的严格控制，确保只有用户自己或同组中的其它成员能够操作属于自己的文件（**root** 用户与特殊权限设定的文件除外）。

#### 进程与线程
另外一个非常重要的资源是用户所创建的进程或线程。下图是我当前系统中的部分进程树，括号中表示进程归属的用户、组。

>
>├─2*[dbus-daemon(longyu)]
>        ├─dbus-launch(longyu)
>        ├─dconf-service(longyu)─┬─{gdbus}
>        │                       └─{gmain}
>        ├─dnsmasq(dnsmasq)
>        ├─evinced(longyu)───{gdbus}
>        ├─evolution-calen(longyu)─┬─{dconf worker}
>        │                         ├─{evolution-calen}
>        │                         ├─{gdbus}
>        │                         ├─{gmain}
>        │                         └─{pool}
>        ├─evolution-sourc(longyu)─┬─{gdbus}
>        │                         └─{gmain}
>
>

同大多数现代操作系统相同，**UNIX** 提供了进程**执行的环境**，以及相关系统调用来以更小的粒度**控制进程的执行**。

一个进程有执行的**入口**，对于 **C** 语言来说，这个入口一般是 **main** 函数。不过这并非不可改变，可以通过编译器提供的选项来指定其它的入口函数，这常见于嵌入式开发中。

**argv** 中保存着命令行参数，**environ** 中保存着环境变量键值对。这两者并非是必须的内容，可以不进行设置。

进程在自**己的地址空间**中运行，各个进程的地址空间**相互独立**。

为了在多个进程之间进行协作，内核提供了多种进**程间通信**的手段，如**信号、命名管道、匿名管道、消息队列、共享内存、信号量、unix domain socket** 等等。

这些任务间通信机制仅仅能够在单个主机中的**不同任务间**进行，如果需要与不同主机上的任务进行通信，可以使用 **socket** 来完成。

进程执行的环境粗浅的介绍到此，在这之后我不得不提的东西是 IO。

## unix  中的 I/O
如果你大概看过 《APUE》，你会发现它用了大量的篇幅来讲 IO 操作相关的知识。你可能会觉得一个简单的 IO 用大量的篇幅来讲可能有点赘述的意思，可当你仔细研究之后你就会发现这个 IO 操作要比表面上看到的更加的复杂。它其实可以算作 unix-like 系统中非常重要的一个基础部分，**再怎么强调它的重要性都不为过。**

也许你听过 "设备即文件" 这样的一句 unix-like 系统上的至理名言。可能你最开始很不以为然，可当你不断的深入研究，你会越来越赞同这句话。

这里我用工作中遇到的一个具体的实例来说明。

### 在 tty 中运行 awtk demo 以检查内存泄露
几天前，我的一位同事向我反馈客户 gui 程序中可能存在着一些内存泄露问题，我需要协助客户进行解决。我对于内存泄露的检测并没有太多的经验。虽然 valgrind 也曾经使用过，不过并没有太深入的研究。

客户的程序是用 awtk 编写的，awtk 里面的文档中提到了检查内存泄露的方法，我就研究了一下。

#### 具体的操作过程
根据 awtk 文档的指导，我发现需要进行如下配置：

1. 用客户的工程在我的主机上编译出一个 framebuffer 版的程序
2. 启用 **vga console mode** 并在 tty 中使用 valgrind 运行此 gui 程序

由于我从来没有在 **tty 中运行过 gui 程序**，我对这样的过程感到不可思议。

搜索资料并进行配置后，我真的能够在 tty 上运行 gui 程序了，这时我才想明白其实这也没什么。

awtk 的 linux framebuffer 操作的是 framebuffer 设备，这个设备在我的电脑上就是 /dev/fb0 文件。通过控制这个文件 gui 就能够正常的显示。实际上 awtk 也不过是一个**平台类型**的应用程序，它不用关心底**层的显示驱动**这些东西，也不**用区别设备与文件**，它直接通过**对文件的操作**就能完成绘制过程。

显示正常后我发现鼠标与键盘都不能用。查看源码发现，鼠标设备与键盘设备也都是通过打开相应的设备文件绑定到程序中的。

鼠标设备使用的是 **/dev/input/mice**，键盘设备使用的是 **/dev/input/event0** 与 **/dev/input/event1**。通过操作这两个文件就能够让键盘与鼠标在 tty 下如同图形界面一样正常工作，这也不过是一些**简单的 IO 操作而已**。

具体的操作过程可以访问 [使用 awtk fb 项目与 valgrind 检测基于 awtk 开发的 gui 程序中的内存泄露问题](https://blog.csdn.net/Longyu_wlz/article/details/97887580)。
## 设备即文件的意义
unix-like 系统中对设备进行了抽象，设备都以文件的形式挂在系统中，对设备的操作也与文件操作相同，这样就以**同一套接口****统一**了大部分对不同设备的操作，为用户带来了极大的便利！

## 文件操作的重要性
unix-like 系统中的众多工具都是针对文件操作的。它们之间可以通过不同的进程间通信的方式进行通信，**组合**起来完成复杂的功能。

在大部分时间内，我们使用操作系统的过程都是在进行文件操作，这是文件操作重要性的一个主要因素。

另一方面由于我们对设备的操作也与文件操作使用的接口相同，这更让文件操作变得非常重要。由此看 《APUE》中花了大量的笔墨来讲解 IO 并没什么不正常，只是我们在最开始时没有意识到 IO 的重要性而已！

## 再次回到 《APUE》的第一章
《APUE》的第一章用了几个示例程序让我们对 UNIX like 系统环境有了相对完整的理解，随着阅读的深入我们会停驻到不同的细节中，不断的完善 unix 系统环境的系统架构，当我们有一天能够从开始到结束描述此环境的时候，我们便可以出师了！

