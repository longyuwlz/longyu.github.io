# 申请与释放内存的问题
申请内存空间时，申请比需求更多的空间，传地址时，只传递需要的大小，当需要进行扩展时，再使用预留的空间。注意释放时要整个释放。实际上 malloc 在申请内存时就预留了部分空间用来存储内存描述信息，返回的是与需求大小相同大小的内存起始地址。

在 free 的时候，我们传递给 malloc 返回的地址，free 通过该地址找到此块内存区域的描述信息，通过修改描述信息就能够完成内存的释放。free(NULL) 不执行任何操作，不会造成异常。

多次 free 一个内存区域将会导致未定义的问题。malloc 与 calloc 一般情况下返回一个已经对齐的类型的指针。malloc 与 calloc 最大的区别在于 calloc 会将申请到的内存空间清 0，这意味着我们调用 calloc 将会有额外的性能开销。不过因此带来的安全性完全可以挽回清 0 的性能损耗。如果我们直接调用 malloc ，并且未显式清空申请到的内存区域，直接访问时就可能造成严重的问题，毕竟此处内存区域的初值是不确定的呀！

free 函数并不会释放一块内存，它会将待释放的内存放到空闲内存链表中，供下一次 malloc、calloc、realloc 使用。并且，相邻的内存块还以按照预设算法进行合并，合并为一个更大的内存区域供程序使用。malloc 从堆中申请内存，可以调用 sbrk 来根据需要动态调整堆的大小。

《APUE》中相关的描述如下:

尽管 sbrk 能够扩展或缩减进程占用的内存，大多数版本的 malloc 和 free 从来不会减少内存大小。我们 free 的空间一般不会返回到内核，而是被放到 malloc 管理的内存池中以供下一次内存申请使用。malloc 的大多数实现都会申请比请求大小更多的空间，并且使用额外的内存空间来存储记录信息——如块的大小，下一个申请块的指针等等。因此，在申请到的块的前后进行写操作可能会覆盖在其它块中保存的记录信息。这种问题很难定位，并且可能在一段时间之后才会发生，但它一旦发生就是一个大的灾难。

另一个可能的错误是释放一个已经释放的内存或者释放一个不是通过调用 malloc、realloc、calloc 函数在堆中申请的内存。当一个进程调用了 malloc 却忘记了调用 free 来释放，未释放的内存不能被回收使用，这被称为内存泄露。如果我们不调用 free 来释放不再使用的内存，可使用的内存会越来越少，直到用完所有的空闲空间。


