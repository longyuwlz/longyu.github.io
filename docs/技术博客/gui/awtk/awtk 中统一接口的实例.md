# awtk 中统一接口的实例
## 统一接口的意义
**1. 对跨平台适配的意义**

不同平台相同的功能，其接口与实现可能都不太相同。通过对需求进行抽象，统一调用接口，将不同平台的变化封装到更低的层次，系统中不直接调用不同平台的函数，而是通过抽象层来与底层对接，对于上层应用来说，这个的做法屏蔽了平台的差异！

**2. 对外部语言绑定的意义**

外部语言绑定时，统一接口有利于使用一套模板来生成代码，减少复杂度的同时也消除了大量重复的过程，这样也便于后期维护。

**3. 对应用开发者的意义**

学习一种控件即可掌握所有控件的关键工作流程，使用同一套接口便可以在不同的控件中运用自如，这样就很容易上手了，也有助于进一步的学习。

**4. 对扩展的意义**

当接口统一之后，很多完整的流程被明确规定，这些流程具体的实现被推迟，实现的细节差异被屏蔽。这样的方式带来的一个很大的好处在于不论你如何修改下层实现，都只会作用于本层，上层甚至于可以完全不用修改就能正常工作，这样你在扩展功能的时候便能够专注于具体的实现，而不必担心会影响到上层的接口。

## [awtk](https://github.com/zlgopen/awtk)  中统一接口的实例
1. main_loop
2. 文件操作
3. 线程操作
4. 控件属性的 set、get 函数
5. 绘制后端接口的统一
6. 按键上报接口的统一
7. ...

## 以 main_loop 与控件为例，探讨统一接口体现的抽象思维
### main_loop
[awtk](https://github.com/zlgopen/awtk)  中的 **main_loop** 是对 【GUI 执行过程的抽象】。在进一步探讨这种抽象的意义之前，我先讲讲我了解的 gui 工作的两种不同方式。

#### 1. 轮询式

#### 2.中断式

**轮询式即在一个过程中按照固定的顺序来执行分发定时器、检测并投递事件、完成绘制等过程，是由 GUI 主动查询事件处理的方式。**

**中断式的处理与轮询式正好相反，它被动接受事件并在被事件唤醒后执行，没有事件发生时可以一直睡眠。**

**尽管中断式实现的执行流有上面的优点，但中断方式的实现相对复杂，轮询式却比较简单**。在轮询的最后也可以添加一个短暂的延时来让出 cpu ，但是这没有改变轮询本质的特点，甚至可能会带来事件响应不及时的问题。

讲到这里我们再来想想之前提到的 【GUI 执行过程的抽象】。无论是轮询还是中断式实现，其执行的过程在抽象的层次上都是【相同的】。

**执行、等待、查询事件、分发事件、睡眠、唤醒或查询事件，这便是 GUI 执行的抽象过程。这里得到的这个抽象过程是一套 GUI 执行的完整工作流程，这样的过程屏蔽了底层轮询式、中断式的差别，这是 [awtk](https://github.com/zlgopen/awtk)  中 main_loop 的特点。**

与 **main_loop** 类似的抽象实现在 [awtk](https://github.com/zlgopen/awtk)  中还能找到很多地方，这些抽象的实现体现了设计者深厚的技术功底！

### 控件
控件是 [awtk](https://github.com/zlgopen/awtk)  的核心，也是用户设计图形界面的基础元素。**每一类控件都是对一种特定功能的抽象，而对所有控件的特点进行抽象便能够得到一套控件设计的完整过程，在更高的层次上将所有控件的行为进行了统一！这样的统一让控件的实现变得简单。**

我曾为 [awtk](https://github.com/zlgopen/awtk)  编写过扩展控件，对于控件抽象行为的统一为扩展控件带来的好处深有感触，而且这种抽象更能进一步降低控件学习的成本。这让我想起了 linux 中设备即文件的抽象实现，都有着类似的原理！而 linux 做的更大，整个 io 系统都可以通过几个系统调用来控制，一套接口玩转所有的 io，让人叹服！
## 总结
**本文从 [awtk](https://github.com/zlgopen/awtk)  中统一接口的一些具体实例出发，进一步探讨了这些实例所体现的抽象思维。这种思维在软件设计中是非常重要的，有了这种思维我们可能能设计出更加优秀的软件作品，这也是控制复杂度的一种强有力的手段！**



