# 以 git + awk 实现批量化操作为例，探讨命令行的处理过程
## 批量化操作的核心是什么
使用 git 操作项目文件时，常常需要对多个文件进行相同的操作。一些图形化程序中提供了多文件操作的支持，不过功能相对简单。也许大部分人并不需要太复杂的功能，但如果有这种功能，许多重复的工作便可以消除，效率也能得到提高。

在这里我们把 git 作为一个简单的命令，此命令有许多选项，每一个选项可能需要一些参数。

我们可以想象，在大多数时间内，参数主要由文件名组成，这些文件名参数中可能存在着不同的模型，或者说能够通过某一正则表达式或其它表达式——如万用字符来描述。

这些模型能够表示出一个文件名的集合，有了这个集合，我们的操作单位便不再局限于单个文件名，而是文件名集合，这样就能够实现批量化操作。

## 实现批量化的限制
不过，必须注意的是，有时候我们很难或者说根本就找不到一个模型来容纳需要的文件名，这可能受限于所使用的描述对象以及自己所掌握的描述能力。这时可以不必苦苦纠结，采用最原始最简单的方法来完成任务即可。

这里我以完成任务为第一要务，这并不是说我们不应该继续尝试寻找一个模型，只是如果一定要先找到一个模型，那样可能需要花费大量的时间，不仅不必要而且会让这个简单的步骤变得复杂。这也说明了并不是所有情况都要先去寻找一个模型。当文件名很少而且你几秒之内想不到一个模型时，直接操作单个文件名可能更好！

## 一些例子：
```sh
    # 批量删除后缀为 .c 的文件
    git status | awk '/deleted.*\.c$/ {print $2}' | xargs -i git rm -rf {} 　
    # 批量添加后缀为 .xml 的文件　
    git status | awk '/modified.*\.xml$/ { print $2 }' | xargs -i git add {}
    ＃批量从仓库中检出后缀名为 .h 的文件名
    git status | awk '/modified.*\.h$/ {print $2}' | xargs -i git checkout {}
```

## 分析
上述示例十分简单，却能够很好的说明问题。在上面的不同操作中，其步骤可以统一叙述如下：

1. 制作输入参数表
2. 编写筛选规则
3. 筛选需要的参数
4. 传递参数并执行需要的命令

**上面的步骤不禁让我想起了 lisp 中序列处理的抽象过程。这个抽象过程从枚举序列开始到对每一个序列元素执行映射，然后筛选需要的结构，构造出新的序列。有了这样的过程，便能够在更高的抽象层次描述问题，序列操作得到了推广。**

虽然上述示例使用命令的形式，但其中的过程与 lisp 中的表操作有着共通之处。

如果要总结一下的话，那么这样的形式可以称为对命令行处理过程的抽象吧！这只是其中的一个实例而已。

