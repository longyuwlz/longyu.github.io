"use strict";(self.webpackChunklongyu_website=self.webpackChunklongyu_website||[]).push([[3885],{3905:function(t,e,n){n.d(e,{Zo:function(){return l},kt:function(){return c}});var _=n(7294);function r(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function d(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var _=Object.getOwnPropertySymbols(t);e&&(_=_.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,_)}return n}function p(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?d(Object(n),!0).forEach((function(e){r(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):d(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function i(t,e){if(null==t)return{};var n,_,r=function(t,e){if(null==t)return{};var n,_,r={},d=Object.keys(t);for(_=0;_<d.length;_++)n=d[_],e.indexOf(n)>=0||(r[n]=t[n]);return r}(t,e);if(Object.getOwnPropertySymbols){var d=Object.getOwnPropertySymbols(t);for(_=0;_<d.length;_++)n=d[_],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(r[n]=t[n])}return r}var a=_.createContext({}),s=function(t){var e=_.useContext(a),n=e;return t&&(n="function"==typeof t?t(e):p(p({},e),t)),n},l=function(t){var e=s(t.components);return _.createElement(a.Provider,{value:e},t.children)},u={inlineCode:"code",wrapper:function(t){var e=t.children;return _.createElement(_.Fragment,{},e)}},o=_.forwardRef((function(t,e){var n=t.components,r=t.mdxType,d=t.originalType,a=t.parentName,l=i(t,["components","mdxType","originalType","parentName"]),o=s(n),c=r,k=o["".concat(a,".").concat(c)]||o[c]||u[c]||d;return n?_.createElement(k,p(p({ref:e},l),{},{components:n})):_.createElement(k,p({ref:e},l))}));function c(t,e){var n=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var d=n.length,p=new Array(d);p[0]=o;var i={};for(var a in e)hasOwnProperty.call(e,a)&&(i[a]=e[a]);i.originalType=t,i.mdxType="string"==typeof t?t:r,p[1]=i;for(var s=2;s<d;s++)p[s]=n[s];return _.createElement.apply(null,p)}return _.createElement.apply(null,n)}o.displayName="MDXCreateElement"},7692:function(t,e,n){n.r(e),n.d(e,{assets:function(){return l},contentTitle:function(){return a},default:function(){return c},frontMatter:function(){return i},metadata:function(){return s},toc:function(){return u}});var _=n(7462),r=n(3366),d=(n(7294),n(3905)),p=["components"],i={},a="dpdk \u95ee\u9898\u5206\u6790\uff1adpdk-19.11 \u6027\u80fd\u4f18\u4e8e dpdk-16.04 \u95ee\u9898\u5206\u6790",s={unversionedId:"\u6280\u672f\u535a\u5ba2/dpdk/dpdk \u95ee\u9898\u6848\u4f8b/\u6027\u80fd\u95ee\u9898/dpdk \u95ee\u9898\u5206\u6790\uff1adpdk-19.11 \u6027\u80fd\u4f18\u4e8e dpdk-16.04 \u95ee\u9898\u5206\u6790",id:"\u6280\u672f\u535a\u5ba2/dpdk/dpdk \u95ee\u9898\u6848\u4f8b/\u6027\u80fd\u95ee\u9898/dpdk \u95ee\u9898\u5206\u6790\uff1adpdk-19.11 \u6027\u80fd\u4f18\u4e8e dpdk-16.04 \u95ee\u9898\u5206\u6790",title:"dpdk \u95ee\u9898\u5206\u6790\uff1adpdk-19.11 \u6027\u80fd\u4f18\u4e8e dpdk-16.04 \u95ee\u9898\u5206\u6790",description:"\u95ee\u9898\u63cf\u8ff0",source:"@site/docs/\u6280\u672f\u535a\u5ba2/dpdk/dpdk \u95ee\u9898\u6848\u4f8b/\u6027\u80fd\u95ee\u9898/dpdk \u95ee\u9898\u5206\u6790\uff1adpdk-19.11 \u6027\u80fd\u4f18\u4e8e dpdk-16.04 \u95ee\u9898\u5206\u6790.md",sourceDirName:"\u6280\u672f\u535a\u5ba2/dpdk/dpdk \u95ee\u9898\u6848\u4f8b/\u6027\u80fd\u95ee\u9898",slug:"/\u6280\u672f\u535a\u5ba2/dpdk/dpdk \u95ee\u9898\u6848\u4f8b/\u6027\u80fd\u95ee\u9898/dpdk \u95ee\u9898\u5206\u6790\uff1adpdk-19.11 \u6027\u80fd\u4f18\u4e8e dpdk-16.04 \u95ee\u9898\u5206\u6790",permalink:"/longyu.github.io/\u6280\u672f\u535a\u5ba2/dpdk/dpdk \u95ee\u9898\u6848\u4f8b/\u6027\u80fd\u95ee\u9898/dpdk \u95ee\u9898\u5206\u6790\uff1adpdk-19.11 \u6027\u80fd\u4f18\u4e8e dpdk-16.04 \u95ee\u9898\u5206\u6790",draft:!1,editUrl:"https://github.com/longyuwlz/longyu.github.io/docs/\u6280\u672f\u535a\u5ba2/dpdk/dpdk \u95ee\u9898\u6848\u4f8b/\u6027\u80fd\u95ee\u9898/dpdk \u95ee\u9898\u5206\u6790\uff1adpdk-19.11 \u6027\u80fd\u4f18\u4e8e dpdk-16.04 \u95ee\u9898\u5206\u6790.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"dpdk \u7a0b\u5e8f\u7ed1\u4e0d\u540c\u7684\u6838\u6027\u80fd\u6709\u660e\u663e\u5dee\u5f02\u95ee\u9898\u5206\u6790",permalink:"/longyu.github.io/\u6280\u672f\u535a\u5ba2/dpdk/dpdk \u95ee\u9898\u6848\u4f8b/\u6027\u80fd\u95ee\u9898/dpdk \u7a0b\u5e8f\u7ed1\u4e0d\u540c\u7684\u6838\u6027\u80fd\u6709\u660e\u663e\u5dee\u5f02\u95ee\u9898\u5206\u6790"},next:{title:"Unsupported SFP+ Module",permalink:"/longyu.github.io/\u6280\u672f\u535a\u5ba2/dpdk/dpdk \u95ee\u9898\u6848\u4f8b/\u63a5\u53e3\u95ee\u9898/Unsupported SFP+ Module"}},l={},u=[{value:"\u95ee\u9898\u63cf\u8ff0",id:"\u95ee\u9898\u63cf\u8ff0",level:2},{value:"\u95ee\u9898\u5206\u6790",id:"\u95ee\u9898\u5206\u6790",level:2},{value:"\u63cf\u8ff0\u7b26\u6570\u91cf\u5dee\u5f02",id:"\u63cf\u8ff0\u7b26\u6570\u91cf\u5dee\u5f02",level:2},{value:"dpdk-16.04",id:"dpdk-1604",level:3},{value:"dpdk-19.11",id:"dpdk-1911",level:3},{value:"\u6bcf\u4e2a mempool \u7684 cache size \u5927\u5c0f\u5dee\u5f02",id:"\u6bcf\u4e2a-mempool-\u7684-cache-size-\u5927\u5c0f\u5dee\u5f02",level:2},{value:"dpdk-16.04",id:"dpdk-1604-1",level:3},{value:"dpdk-19.11",id:"dpdk-1911-1",level:3},{value:"\u5411\u91cf\u6536\u53d1\u5305\u51fd\u6570\u5b9e\u73b0\u5dee\u5f02",id:"\u5411\u91cf\u6536\u53d1\u5305\u51fd\u6570\u5b9e\u73b0\u5dee\u5f02",level:2},{value:"\u6d4b\u8bd5\u5efa\u8bae",id:"\u6d4b\u8bd5\u5efa\u8bae",level:2},{value:"\u5b9e\u9645\u7684\u6d4b\u8bd5\u7ed3\u679c",id:"\u5b9e\u9645\u7684\u6d4b\u8bd5\u7ed3\u679c",level:2}],o={toc:u};function c(t){var e=t.components,n=(0,r.Z)(t,p);return(0,d.kt)("wrapper",(0,_.Z)({},o,n,{components:e,mdxType:"MDXLayout"}),(0,d.kt)("h1",{id:"dpdk-\u95ee\u9898\u5206\u6790dpdk-1911-\u6027\u80fd\u4f18\u4e8e-dpdk-1604-\u95ee\u9898\u5206\u6790"},"dpdk \u95ee\u9898\u5206\u6790\uff1adpdk-19.11 \u6027\u80fd\u4f18\u4e8e dpdk-16.04 \u95ee\u9898\u5206\u6790"),(0,d.kt)("h2",{id:"\u95ee\u9898\u63cf\u8ff0"},"\u95ee\u9898\u63cf\u8ff0"),(0,d.kt)("p",null,(0,d.kt)("strong",{parentName:"p"},"\u67d0\u98de\u817e arm \u8bbe\u5907"),"\uff0c\u8fd0\u884c dpdk-19.11 l2fwd\uff0c",(0,d.kt)("strong",{parentName:"p"},"\u4e24\u4e2a\u6838\u5c0f\u5305\u7eaf\u8f6c\u53d1"),"\u5728 ",(0,d.kt)("strong",{parentName:"p"},"55% \u4ee5\u4e0a"),"\uff0c\u8fd0\u884c dpdk-16.04 l2fwd\uff0c",(0,d.kt)("strong",{parentName:"p"},"\u4e24\u4e2a\u6838\u5c0f\u5305\u7eaf\u8f6c\u53d1 21%"),"\u3002"),(0,d.kt)("p",null,(0,d.kt)("strong",{parentName:"p"},"\u5c0f\u5305\u6027\u80fd\u8fdc\u4f4e\u4e8e\u9884\u671f\uff01")),(0,d.kt)("p",null,"\u5907\u6ce8\uff1a\u7ed1\u6838\u60c5\u51b5\u76f8\u540c\uff01"),(0,d.kt)("h2",{id:"\u95ee\u9898\u5206\u6790"},"\u95ee\u9898\u5206\u6790"),(0,d.kt)("ol",null,(0,d.kt)("li",{parentName:"ol"},"dpdk-19.11 \u4f18\u5316\u4e86 rte_mbuf \u4e2d\u7684\u7ed3\u6784\uff0c\u5bf9\u6027\u80fd\u6709\u5f71\u54cd"),(0,d.kt)("li",{parentName:"ol"},"dpdk-19.11 l2fwd \u4f7f\u7528\u7684\u63cf\u8ff0\u7b26\u7684\u6570\u91cf\u4e0e dpdk-16.04 l2fwd \u53ef\u80fd\u5b58\u5728",(0,d.kt)("strong",{parentName:"li"},"\u5dee\u5f02")),(0,d.kt)("li",{parentName:"ol"},"dpdk-19.11 rte_mbuf \u7ed3\u6784\u8c03\u6574\uff0carm neno \u5411\u91cf\u6536\u53d1\u5305\u51fd\u6570\u6709\u51e0\u4e2a\u6307\u4ee4\u7684\u4f18\u5316\uff0c\u6027\u80fd\u8981\u6bd4 dpdk-16.04 \u66f4\u4f18\uff0c\u4f46\u662f\u5dee\u522b\u4e0d\u4f1a\u7279\u522b\u5927"),(0,d.kt)("li",{parentName:"ol"},"\u8bbe\u5907\u67b6\u6784\u4e3a\u5355 numa \u7ed3\u6784\uff0c\u4e0d\u5b58\u5728\u8de8 numa \u95ee\u9898")),(0,d.kt)("p",null,(0,d.kt)("strong",{parentName:"p"},"\u5728 x86 \u4e0a\uff0cdpdk-19.11 \u5728\u4e00\u4e9b\u5e73\u53f0\u80fd\u591f\u4f7f\u7528 avx2\u3001avx512 \u6536\u53d1\u5305\u51fd\u6570\uff0c\u5bf9\u5c0f\u5305\u6027\u80fd\u6709\u660e\u663e\u7684\u4f18\u5316\u3002")),(0,d.kt)("p",null,"\u4e3b\u8981\u5206\u6790\u65b9\u5411\uff1a"),(0,d.kt)("ol",null,(0,d.kt)("li",{parentName:"ol"},"\u786e\u8ba4\u63cf\u8ff0\u7b26\u6570\u91cf\u5dee\u5f02 "),(0,d.kt)("li",{parentName:"ol"},"\u786e\u8ba4\u5411\u91cf\u6536\u53d1\u5305\u51fd\u6570\u5dee\u5f02"),(0,d.kt)("li",{parentName:"ol"},"\u786e\u8ba4\u5176\u5b83\u914d\u7f6e\u4e0a\u7684\u5dee\u5f02")),(0,d.kt)("h2",{id:"\u63cf\u8ff0\u7b26\u6570\u91cf\u5dee\u5f02"},"\u63cf\u8ff0\u7b26\u6570\u91cf\u5dee\u5f02"),(0,d.kt)("h3",{id:"dpdk-1604"},"dpdk-16.04"),(0,d.kt)("p",null,"#define RTE_TEST_RX_DESC_DEFAULT 128\n#define RTE_TEST_TX_DESC_DEFAULT 512"),(0,d.kt)("h3",{id:"dpdk-1911"},"dpdk-19.11"),(0,d.kt)("p",null,"#define RTE_TEST_RX_DESC_DEFAULT 1024\n#define RTE_TEST_TX_DESC_DEFAULT 1024"),(0,d.kt)("p",null,"\u5dee\u5f02\u5206\u6790\u7ed3\u8bba\uff1a",(0,d.kt)("strong",{parentName:"p"},"dpdk-19.11 \u914d\u7f6e\u7684\u63cf\u8ff0\u7b26\u6570\u91cf\u9ad8\u4e8e dpdk-16.04"),"\u3002"),(0,d.kt)("h2",{id:"\u6bcf\u4e2a-mempool-\u7684-cache-size-\u5927\u5c0f\u5dee\u5f02"},"\u6bcf\u4e2a mempool \u7684 cache size \u5927\u5c0f\u5dee\u5f02"),(0,d.kt)("h3",{id:"dpdk-1604-1"},"dpdk-16.04"),(0,d.kt)("p",null,"#define MEMPOOL_CACHE_SIZE 32"),(0,d.kt)("h3",{id:"dpdk-1911-1"},"dpdk-19.11"),(0,d.kt)("p",null,"#define MEMPOOL_CACHE_SIZE 256"),(0,d.kt)("p",null,"\u5dee\u5f02\u5206\u6790\u7ed3\u8bba\uff1a",(0,d.kt)("strong",{parentName:"p"},"dpdk-19.11 \u914d\u7f6e\u7684 mempool \u7684 cache_size \u7684\u5927\u5c0f\u662f dpdk-16.04 \u7684 8 \u500d"),"\u3002"),(0,d.kt)("h2",{id:"\u5411\u91cf\u6536\u53d1\u5305\u51fd\u6570\u5b9e\u73b0\u5dee\u5f02"},"\u5411\u91cf\u6536\u53d1\u5305\u51fd\u6570\u5b9e\u73b0\u5dee\u5f02"),(0,d.kt)("p",null,"diff \u5bf9\u6bd4\u5f97\u5230\u7684\u5dee\u5f02\u70b9\uff1a"),(0,d.kt)("pre",null,(0,d.kt)("code",{parentName:"pre",className:"language-c"},'git diff   ~/dpdk-16.04/drivers/net/i40e/i40e_rxtx_vec_neon.c  ~/dpdk-19.11/drivers/net/i40e/i40e_rxtx_vec_neon.c\n--- a/home/longyu/dpdk-16.04/drivers/net/i40e/i40e_rxtx_vec_neon.c\n+++ b/home/longyu/dpdk-19.11/drivers/net/i40e/i40e_rxtx_vec_neon.c\n\n#include <stdint.h>\n-#include <rte_ethdev.h>\n+#include <rte_ethdev_driver.h>\n #include <rte_malloc.h>\n\n #include "base/i40e_prototype.h"\n@@ -57,7 +28,6 @@ i40e_rxq_rearm(struct i40e_rx_queue *rxq)\n        uint64x2_t dma_addr0, dma_addr1;\n        uint64x2_t zero = vdupq_n_u64(0);\n        uint64_t paddr;\n-       uint8x8_t p;\n\n        rxdp = rxq->rx_ring + rxq->rxrearm_start;\n\n@@ -77,28 +47,18 @@ i40e_rxq_rearm(struct i40e_rx_queue *rxq)\n                return;\n        }\n\n-       p = vld1_u8((uint8_t *)&rxq->mbuf_initializer);\n-\n        /* Initialize the mbufs in vector, process 2 mbufs in one loop */\n        for (i = 0; i < RTE_I40E_RXQ_REARM_THRESH; i += 2, rxep += 2) {\n                mb0 = rxep[0].mbuf;\n                mb1 = rxep[1].mbuf;\n\n-                /* Flush mbuf with pkt template.\n-                * Data to be rearmed is 6 bytes long.\n-                * Though, RX will overwrite ol_flags that are coming next\n-                * anyway. So overwrite whole 8 bytes with one load:\n-                * 6 bytes of rearm_data plus first 2 bytes of ol_flags.\n-                */\n-               vst1_u8((uint8_t *)&mb0->rearm_data, p);\n-               paddr = mb0->buf_physaddr + RTE_PKTMBUF_HEADROOM;\n+               paddr = mb0->buf_iova + RTE_PKTMBUF_HEADROOM;\n                dma_addr0 = vdupq_n_u64(paddr);\n\n                /* flush desc with pa dma_addr */\n                vst1q_u64((uint64_t *)&rxdp++->read, dma_addr0);\n\n-               vst1_u8((uint8_t *)&mb1->rearm_data, p);\n-               paddr = mb1->buf_physaddr + RTE_PKTMBUF_HEADROOM;\n+               paddr = mb1->buf_iova + RTE_PKTMBUF_HEADROOM;\n                dma_addr1 = vdupq_n_u64(paddr);\n                vst1q_u64((uint64_t *)&rxdp++->read, dma_addr1);\n        }\n@@ -116,18 +76,13 @@ i40e_rxq_rearm(struct i40e_rx_queue *rxq)\n        I40E_PCI_REG_WRITE(rxq->qrx_tail, rx_id);\n }\n\n-/* Handling the offload flags (olflags) field takes computation\n- * time when receiving packets. Therefore we provide a flag to disable\n- * the processing of the olflags field when they are not needed. This\n- * gives improved performance, at the cost of losing the offload info\n- * in the received packet\n- */\n-#ifdef RTE_LIBRTE_I40E_RX_OLFLAGS_ENABLE\n-\n static inline void\n-desc_to_olflags_v(uint64x2_t descs[4], struct rte_mbuf **rx_pkts)\n+desc_to_olflags_v(struct i40e_rx_queue *rxq, uint64x2_t descs[4],\n+                 struct rte_mbuf **rx_pkts)\n {\n        uint32x4_t vlan0, vlan1, rss, l3_l4e;\n+       const uint64x2_t mbuf_init = {rxq->mbuf_initializer, 0};\n+       uint64x2_t rearm0, rearm1, rearm2, rearm3;\n\n        /* mask everything except RSS, flow director and VLAN flags\n         * bit2 is for VLAN tag, bit11 for flow director indication\n@@ -136,10 +91,24 @@ desc_to_olflags_v(uint64x2_t descs[4], struct rte_mbuf **rx_pkts)\n        const uint32x4_t rss_vlan_msk = {\n                        0x1c03804, 0x1c03804, 0x1c03804, 0x1c03804};\n\n+       const uint32x4_t cksum_mask = {\n+                       PKT_RX_IP_CKSUM_GOOD | PKT_RX_IP_CKSUM_BAD |\n+                       PKT_RX_L4_CKSUM_GOOD | PKT_RX_L4_CKSUM_BAD |\n+                       PKT_RX_EIP_CKSUM_BAD,\n+                       PKT_RX_IP_CKSUM_GOOD | PKT_RX_IP_CKSUM_BAD |\n+                       PKT_RX_L4_CKSUM_GOOD | PKT_RX_L4_CKSUM_BAD |\n+                       PKT_RX_EIP_CKSUM_BAD,\n+                       PKT_RX_IP_CKSUM_GOOD | PKT_RX_IP_CKSUM_BAD |\n+                       PKT_RX_L4_CKSUM_GOOD | PKT_RX_L4_CKSUM_BAD |\n+                       PKT_RX_EIP_CKSUM_BAD,\n+                       PKT_RX_IP_CKSUM_GOOD | PKT_RX_IP_CKSUM_BAD |\n+                       PKT_RX_L4_CKSUM_GOOD | PKT_RX_L4_CKSUM_BAD |\n+                       PKT_RX_EIP_CKSUM_BAD};\n+\n        /* map rss and vlan type to rss hash and vlan flag */\n        const uint8x16_t vlan_flags = {\n                        0, 0, 0, 0,\n-                       PKT_RX_VLAN_PKT | PKT_RX_VLAN_STRIPPED, 0, 0, 0,\n+                       PKT_RX_VLAN | PKT_RX_VLAN_STRIPPED, 0, 0, 0,\n                        0, 0, 0, 0,\n                        0, 0, 0, 0};\n\n@@ -150,14 +119,16 @@ desc_to_olflags_v(uint64x2_t descs[4], struct rte_mbuf **rx_pkts)\n                        0, 0, 0, 0};\n\n        const uint8x16_t l3_l4e_flags = {\n-                       0,\n-                       PKT_RX_IP_CKSUM_BAD,\n-                       PKT_RX_L4_CKSUM_BAD,\n-                       PKT_RX_L4_CKSUM_BAD | PKT_RX_IP_CKSUM_BAD,\n-                       PKT_RX_EIP_CKSUM_BAD,\n-                       PKT_RX_EIP_CKSUM_BAD | PKT_RX_IP_CKSUM_BAD,\n-                       PKT_RX_EIP_CKSUM_BAD | PKT_RX_L4_CKSUM_BAD,\n-                       PKT_RX_EIP_CKSUM_BAD | PKT_RX_L4_CKSUM_BAD | PKT_RX_IP_CKSUM_BAD,\n+                       (PKT_RX_IP_CKSUM_GOOD | PKT_RX_L4_CKSUM_GOOD) >> 1,\n+                       PKT_RX_IP_CKSUM_BAD >> 1,\n+                       (PKT_RX_IP_CKSUM_GOOD | PKT_RX_L4_CKSUM_BAD) >> 1,\n+                       (PKT_RX_L4_CKSUM_BAD | PKT_RX_IP_CKSUM_BAD) >> 1,\n+                       (PKT_RX_IP_CKSUM_GOOD | PKT_RX_EIP_CKSUM_BAD) >> 1,\n+                       (PKT_RX_EIP_CKSUM_BAD | PKT_RX_IP_CKSUM_BAD) >> 1,\n+                       (PKT_RX_IP_CKSUM_GOOD | PKT_RX_EIP_CKSUM_BAD |\n+                        PKT_RX_L4_CKSUM_BAD) >> 1,\n+                       (PKT_RX_EIP_CKSUM_BAD | PKT_RX_L4_CKSUM_BAD |\n+                        PKT_RX_IP_CKSUM_BAD) >> 1,\n                        0, 0, 0, 0, 0, 0, 0, 0};\n\n        vlan0 = vzipq_u32(vreinterpretq_u32_u64(descs[0]),\n@@ -177,25 +148,31 @@ desc_to_olflags_v(uint64x2_t descs[4], struct rte_mbuf **rx_pkts)\n        l3_l4e = vshrq_n_u32(vlan1, 22);\n        l3_l4e = vreinterpretq_u32_u8(vqtbl1q_u8(l3_l4e_flags,\n                                              vreinterpretq_u8_u32(l3_l4e)));\n-\n+       /* then we shift left 1 bit */\n+       l3_l4e = vshlq_n_u32(l3_l4e, 1);\n+       /* we need to mask out the reduntant bits */\n+       l3_l4e = vandq_u32(l3_l4e, cksum_mask);\n\n        vlan0 = vorrq_u32(vlan0, rss);\n        vlan0 = vorrq_u32(vlan0, l3_l4e);\n\n-       rx_pkts[0]->ol_flags = vgetq_lane_u32(vlan0, 0);\n-       rx_pkts[1]->ol_flags = vgetq_lane_u32(vlan0, 1);\n-       rx_pkts[2]->ol_flags = vgetq_lane_u32(vlan0, 2);\n-       rx_pkts[3]->ol_flags = vgetq_lane_u32(vlan0, 3);\n+       rearm0 = vsetq_lane_u64(vgetq_lane_u32(vlan0, 0), mbuf_init, 1);\n+       rearm1 = vsetq_lane_u64(vgetq_lane_u32(vlan0, 1), mbuf_init, 1);\n+       rearm2 = vsetq_lane_u64(vgetq_lane_u32(vlan0, 2), mbuf_init, 1);\n+       rearm3 = vsetq_lane_u64(vgetq_lane_u32(vlan0, 3), mbuf_init, 1);\n+\n+       vst1q_u64((uint64_t *)&rx_pkts[0]->rearm_data, rearm0);\n+       vst1q_u64((uint64_t *)&rx_pkts[1]->rearm_data, rearm1);\n+       vst1q_u64((uint64_t *)&rx_pkts[2]->rearm_data, rearm2);\n+       vst1q_u64((uint64_t *)&rx_pkts[3]->rearm_data, rearm3);\n }\n-#else\n-#define desc_to_olflags_v(descs, rx_pkts) do {} while (0)\n-#endif\n\n #define PKTLEN_SHIFT     10\n #define I40E_UINT16_BIT (CHAR_BIT * sizeof(uint16_t))\n\n static inline void\n-desc_to_ptype_v(uint64x2_t descs[4], struct rte_mbuf **rx_pkts)\n+desc_to_ptype_v(uint64x2_t descs[4], struct rte_mbuf **rx_pkts,\n+               uint32_t *ptype_tbl)\n {\n        int i;\n        uint8_t ptype;\n@@ -204,7 +181,7 @@ desc_to_ptype_v(uint64x2_t descs[4], struct rte_mbuf **rx_pkts)\n        for (i = 0; i < 4; i++) {\n                tmp = vreinterpretq_u8_u64(vshrq_n_u64(descs[i], 30));\n                ptype = vgetq_lane_u8(tmp, 8);\n-               rx_pkts[i]->packet_type = i40e_rxd_pkt_type_mapping(ptype);\n+               rx_pkts[i]->packet_type = ptype_tbl[ptype];\n        }\n\n }\n@@ -223,6 +200,7 @@ _recv_raw_pkts_vec(struct i40e_rx_queue *rxq, struct rte_mbuf **rx_pkts,\n        struct i40e_rx_entry *sw_ring;\n        uint16_t nb_pkts_recd;\n        int pos;\n+       uint32_t *ptype_tbl = rxq->vsi->adapter->ptype_tbl;\n\n        /* mask to shuffle from desc. to mbuf */\n        uint8x16_t shuf_msk = {\n@@ -307,7 +285,6 @@ _recv_raw_pkts_vec(struct i40e_rx_queue *rxq, struct rte_mbuf **rx_pkts,\n                /* Read desc statuses backwards to avoid race condition */\n                /* A.1 load 4 pkts desc */\n                descs[3] =  vld1q_u64((uint64_t *)(rxdp + 3));\n-               rte_rmb();\n\n                /* B.2 copy 2 mbuf point into rx_pkts  */\n                vst1q_u64((uint64_t *)&rx_pkts[pos], mbp1);\n@@ -330,9 +307,6 @@ _recv_raw_pkts_vec(struct i40e_rx_queue *rxq, struct rte_mbuf **rx_pkts,\n                        rte_mbuf_prefetch_part2(rx_pkts[pos + 3]);\n                }\n\n-               /* avoid compiler reorder optimization */\n-               rte_compiler_barrier();\n-\n                /* pkt 3,4 shift the pktlen field to be 16-bit aligned*/\n                uint32x4_t len3 = vshlq_u32(vreinterpretq_u32_u64(descs[3]),\n                                            len_shl);\n@@ -356,7 +330,7 @@ _recv_raw_pkts_vec(struct i40e_rx_queue *rxq, struct rte_mbuf **rx_pkts,\n                staterr = vzipq_u16(sterr_tmp1.val[1],\n                                    sterr_tmp2.val[1]).val[0];\n\n-               desc_to_olflags_v(descs, &rx_pkts[pos]);\n+               desc_to_olflags_v(rxq, descs, &rx_pkts[pos]);\n\n                /* D.2 pkt 3,4 set in_port/nb_seg and remove crc */\n                tmp = vsubq_u16(vreinterpretq_u16_u8(pkt_mb4), crc_adjust);\n@@ -432,7 +406,7 @@ _recv_raw_pkts_vec(struct i40e_rx_queue *rxq, struct rte_mbuf **rx_pkts,\n                         pkt_mb2);\n                vst1q_u8((void *)&rx_pkts[pos]->rx_descriptor_fields1,\n                         pkt_mb1);\n-               desc_to_ptype_v(descs, &rx_pkts[pos]);\n+               desc_to_ptype_v(descs, &rx_pkts[pos], ptype_tbl);\n                /* C.4 calc avaialbe number of desc */\n                if (unlikely(stat == 0)) {\n                        nb_pkts_recd += RTE_I40E_DESCS_PER_LOOP;\n@@ -500,6 +474,7 @@ i40e_recv_scattered_pkts_vec(void *rx_queue, struct rte_mbuf **rx_pkts,\n                        i++;\n                if (i == nb_bufs)\n                        return nb_bufs;\n+               rxq->pkt_first_seg = rx_pkts[i];\n        }\n        return i + reassemble_packets(rxq, &rx_pkts[i], nb_bufs - i,\n                &split_flags[i]);\n@@ -513,7 +488,7 @@ vtx1(volatile struct i40e_tx_desc *txdp,\n                        ((uint64_t)flags  << I40E_TXD_QW1_CMD_SHIFT) |\n                        ((uint64_t)pkt->data_len << I40E_TXD_QW1_TX_BUF_SZ_SHIFT));\n\n-       uint64x2_t descriptor = {pkt->buf_physaddr + pkt->data_off, high_qw};\n+       uint64x2_t descriptor = {pkt->buf_iova + pkt->data_off, high_qw};\n        vst1q_u64((uint64_t *)txdp, descriptor);\n }\n\n@@ -589,7 +564,6 @@ i40e_xmit_fixed_burst_vec(void *tx_queue, struct rte_mbuf **tx_pkts,\n\n        txq->tx_tail = tx_id;\n\n-       rte_wmb();\n        I40E_PCI_REG_WRITE(txq->qtx_tail, txq->tx_tail);\n\n        return nb_pkts;\n')),(0,d.kt)("p",null,"\u5dee\u5f02\u5206\u6790\u7ed3\u8bba\uff1a",(0,d.kt)("strong",{parentName:"p"},"\u5411\u91cf\u6536\u53d1\u5305\u51fd\u6570\u7684\u903b\u8f91\u5dee\u5f02\u4e0d\u662f\u592a\u5927\uff0cdpdk-19.11 \u589e\u52a0\u4e86\u4e00\u4e9b\u65b0\u7684\u903b\u8f91\uff0c\u6b64\u5916\u5bf9 rearm_data \u6807\u8bc6\u5904\u7684\u5904\u7406\u903b\u8f91\u5b58\u5728\u5dee\u5f02\uff0c\u5176\u5b83\u8fc7\u7a0b\u5dee\u5f02\u4e0d\u5927"),"\u3002"),(0,d.kt)("h2",{id:"\u6d4b\u8bd5\u5efa\u8bae"},"\u6d4b\u8bd5\u5efa\u8bae"),(0,d.kt)("ol",null,(0,d.kt)("li",{parentName:"ol"},"\u8c03\u5927 dpdk-16.04 \u7684\u63cf\u8ff0\u7b26\u5927\u5c0f"),(0,d.kt)("li",{parentName:"ol"},"\u8c03\u5927 dpdk-16.04 \u521b\u5efa mempool \u65f6\u5019\u8bbe\u7f6e\u7684 cache_size \u7684\u503c")),(0,d.kt)("h2",{id:"\u5b9e\u9645\u7684\u6d4b\u8bd5\u7ed3\u679c"},"\u5b9e\u9645\u7684\u6d4b\u8bd5\u7ed3\u679c"),(0,d.kt)("p",null,"\u4fee\u6539\u4e0a\u9762\u4e24\u70b9\u540e\uff0c\u6d4b\u8bd5\u786e\u5b9a\u6027\u80fd\u5f97\u5230\u63d0\u9ad8\uff0c\u7b26\u5408\u9884\u671f\uff0c\u95ee\u9898\u5f97\u5230\u89e3\u51b3\u3002"))}c.isMDXComponent=!0}}]);