"use strict";(self.webpackChunklongyu_website=self.webpackChunklongyu_website||[]).push([[2733],{3905:function(n,e,t){t.d(e,{Zo:function(){return d},kt:function(){return p}});var i=t(7294);function _(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function r(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);e&&(i=i.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,i)}return t}function k(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?r(Object(t),!0).forEach((function(e){_(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function l(n,e){if(null==n)return{};var t,i,_=function(n,e){if(null==n)return{};var t,i,_={},r=Object.keys(n);for(i=0;i<r.length;i++)t=r[i],e.indexOf(t)>=0||(_[t]=n[t]);return _}(n,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);for(i=0;i<r.length;i++)t=r[i],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(_[t]=n[t])}return _}var o=i.createContext({}),a=function(n){var e=i.useContext(o),t=e;return n&&(t="function"==typeof n?n(e):k(k({},e),n)),t},d=function(n){var e=a(n.components);return i.createElement(o.Provider,{value:e},n.children)},s={inlineCode:"code",wrapper:function(n){var e=n.children;return i.createElement(i.Fragment,{},e)}},c=i.forwardRef((function(n,e){var t=n.components,_=n.mdxType,r=n.originalType,o=n.parentName,d=l(n,["components","mdxType","originalType","parentName"]),c=a(t),p=_,u=c["".concat(o,".").concat(p)]||c[p]||s[p]||r;return t?i.createElement(u,k(k({ref:e},d),{},{components:t})):i.createElement(u,k({ref:e},d))}));function p(n,e){var t=arguments,_=e&&e.mdxType;if("string"==typeof n||_){var r=t.length,k=new Array(r);k[0]=c;var l={};for(var o in e)hasOwnProperty.call(e,o)&&(l[o]=e[o]);l.originalType=n,l.mdxType="string"==typeof n?n:_,k[1]=l;for(var a=2;a<r;a++)k[a]=t[a];return i.createElement.apply(null,k)}return i.createElement.apply(null,t)}c.displayName="MDXCreateElement"},4508:function(n,e,t){t.r(e),t.d(e,{assets:function(){return d},contentTitle:function(){return o},default:function(){return p},frontMatter:function(){return l},metadata:function(){return a},toc:function(){return s}});var i=t(7462),_=t(3366),r=(t(7294),t(3905)),k=["components"],l={},o=void 0,a={permalink:"/longyu.github.io/blog/dpdk/dpdk-16.04 rte_kni \u6a21\u5757\u5206\u6790",editUrl:"https://github.com/longyuwlz/longyu.github.io/blog/dpdk/dpdk-16.04 rte_kni \u6a21\u5757\u5206\u6790.md",source:"@site/blog/dpdk/dpdk-16.04 rte_kni \u6a21\u5757\u5206\u6790.md",title:"dpdk/dpdk-16.04 rte_kni \u6a21\u5757\u5206\u6790",description:"\u524d\u8a00",date:"2022-06-21T00:32:49.000Z",formattedDate:"2022\u5e746\u670821\u65e5",tags:[],readingTime:24.245,truncated:!1,authors:[],frontMatter:{},prevItem:{title:"\u95ee\u9898\u63cf\u8ff0",permalink:"/longyu.github.io/blog/dpdk/dpdk-16.04 rte_kni \u6a21\u5757\u4e0e\u5185\u6838\u5185\u5b58\u6cc4\u9732\u95ee\u9898"},nextItem:{title:"dpdk/dpdk-16.04 rte_spinlock.h rte_cpu_get_flag_enabled \u63a5\u53e3\u95ee\u9898",permalink:"/longyu.github.io/blog/dpdk/dpdk-16.04 rte_spinlock.h rte_cpu_get_flag_enabled \u63a5\u53e3\u95ee\u9898"}},d={authorsImageUrls:[]},s=[{value:"\u524d\u8a00",id:"\u524d\u8a00",level:2},{value:"rte_kni \u6a21\u5757\u7684\u76ee\u5f55\u7ed3\u6784",id:"rte_kni-\u6a21\u5757\u7684\u76ee\u5f55\u7ed3\u6784",level:2},{value:"kni \u6a21\u5757\u521d\u59cb\u5316\u8fc7\u7a0b",id:"kni-\u6a21\u5757\u521d\u59cb\u5316\u8fc7\u7a0b",level:2},{value:"kni misc \u9a71\u52a8\u7684\u539f\u7406",id:"kni-misc-\u9a71\u52a8\u7684\u539f\u7406",level:2},{value:"kni_open",id:"kni_open",level:3},{value:"kni_ioctl \u51fd\u6570",id:"kni_ioctl-\u51fd\u6570",level:3},{value:"kni_ioctl_create \u51fd\u6570",id:"kni_ioctl_create-\u51fd\u6570",level:3},{value:"rte_kni \u865a\u62df\u7f51\u7edc\u63a5\u53e3\u7684\u6536\u5305\u51fd\u6570",id:"rte_kni-\u865a\u62df\u7f51\u7edc\u63a5\u53e3\u7684\u6536\u5305\u51fd\u6570",level:2},{value:"rte_kni \u865a\u62df\u7f51\u7edc\u63a5\u53e3\u7684\u53d1\u5305\u51fd\u6570",id:"rte_kni-\u865a\u62df\u7f51\u7edc\u63a5\u53e3\u7684\u53d1\u5305\u51fd\u6570",level:2},{value:"rte_kni \u865a\u62df\u63a5\u53e3\u6536\u53d1\u5305\u4e2d mbuf \u7684\u6d41\u52a8\u8fc7\u7a0b",id:"rte_kni-\u865a\u62df\u63a5\u53e3\u6536\u53d1\u5305\u4e2d-mbuf-\u7684\u6d41\u52a8\u8fc7\u7a0b",level:2},{value:"\u91ca\u653e kni \u865a\u62df\u63a5\u53e3\u7684\u8fc7\u7a0b",id:"\u91ca\u653e-kni-\u865a\u62df\u63a5\u53e3\u7684\u8fc7\u7a0b",level:2},{value:"\u4e3a\u4ec0\u4e48 dpdk \u7a0b\u5e8f\u88ab\u5f3a\u5236\u6740\u6b7b\u7684\u65f6\u5019 kni \u63a5\u53e3\u88ab\u91ca\u653e\uff1f",id:"\u4e3a\u4ec0\u4e48-dpdk-\u7a0b\u5e8f\u88ab\u5f3a\u5236\u6740\u6b7b\u7684\u65f6\u5019-kni-\u63a5\u53e3\u88ab\u91ca\u653e",level:2},{value:"rte_kni \u6a21\u5757\u7684\u89e3\u521d\u59cb\u5316\u51fd\u6570",id:"rte_kni-\u6a21\u5757\u7684\u89e3\u521d\u59cb\u5316\u51fd\u6570",level:2}],c={toc:s};function p(n){var e=n.components,t=(0,_.Z)(n,k);return(0,r.kt)("wrapper",(0,i.Z)({},c,t,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"\u524d\u8a00"},"\u524d\u8a00"),(0,r.kt)("p",null,"rte_kni \u6a21\u5757\u5145\u5f53\u4e86\u7528\u6237\u6001\u9a71\u52a8\u4e0e\u5185\u6838\u534f\u8bae\u6808\u4e4b\u95f4\u7684\u6865\u6881\uff0c\u8ba9 dpdk \u7a0b\u5e8f\u80fd\u591f\u4e0a\u9001\u6d41\u91cf\u5230\u5185\u6838\u534f\u8bae\u6808\uff0c\u540c\u65f6\u4e5f\u652f\u6301\u4f7f\u7528 ethtool\u3001ifconfig \u7b49\u91cd\u8981\u7684\u7f51\u7edc\u7ba1\u7406\u547d\u4ee4\u6765\u63a7\u5236\u63a5\u53e3\u72b6\u6001\u3002"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"rte_kni \u6a21\u5757\u53ef\u4ee5\u770b\u4f5c\u662f\u4e00\u4e2a\u865a\u62df\u7684\u7f51\u5361\u9a71\u52a8\uff0c\u7b26\u5408\u7f51\u5361\u9a71\u52a8\u7684\u5e38\u89c1\u7279\u5f81\uff0c\u5176\u6536\u53d1\u5305\u8fc7\u7a0b\u5374\u4e0e\u7f51\u5361\u9a71\u52a8\u6709\u5f88\u5927\u7684\u5dee\u522b\uff0c\u63a5\u53e3\u63a7\u5236\u8fc7\u7a0b\u4e5f\u4e0d\u540c\u4e8e\u666e\u901a\u7684\u7f51\u5361\u9a71\u52a8\uff0c\u5b83\u6d89\u53ca\u4e0e pmd \u4e2d\u9891\u7e41\u7684\u4ea4\u4e92\u5de5\u4f5c\uff0c\u8fd9\u662f rte_kni \u529f\u80fd\u7684\u91cd\u70b9\u3002")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"rte_kni \u5b9e\u73b0\u4e86\u4e00\u4e2a\u865a\u62df\u7f51\u5361\u9a71\u52a8\uff0c\u4e0d\u5b58\u5728\u7f51\u5361 probe \u8fc7\u7a0b\uff0c\u6545\u800c\u4e0d\u80fd\u76f4\u63a5\u521d\u59cb\u5316\u3002\u540c\u65f6 kni \u865a\u62df\u7f51\u5361\u7684\u521d\u59cb\u5316\u4e5f\u4f9d\u8d56\u8bf8\u591a\u7528\u6237\u6001\u63d0\u4f9b\u7684\u53c2\u6570\uff0c\u4e0d\u7b26\u5408\u6b63\u5e38\u865a\u62df\u7f51\u5361\u9a71\u52a8\u6d41\u7a0b\u3002")),(0,r.kt)("p",null,"\u57fa\u4e8e\u8fd9\u4e9b\u56e0\u7d20\uff0crte_kni \u8fd8\u5b9e\u73b0\u4e86\u4e00\u4e2a\u5b57\u7b26\u9a71\u52a8\uff0c",(0,r.kt)("strong",{parentName:"p"},"\u901a\u8fc7\u5b57\u7b26\u9a71\u52a8\u7684 open\u3001ioctl\u3001release \u6765\u63a7\u5236\u865a\u62df\u7f51\u5361\u63a5\u53e3\u7684\u521b\u5efa\u3001\u91ca\u653e\u8fc7\u7a0b\uff0c\u800c\u865a\u62df\u63a5\u53e3\u4f9d\u8d56\u7684\u8bf8\u591a\u53c2\u6570\u4e5f\u80fd\u901a\u8fc7 ioctl \u6765\u63d0\u4f9b\u3002")),(0,r.kt)("p",null,"\u540c\u65f6\u4e3a\u4e86\u652f\u6301 ethtool \u547d\u4ee4\u83b7\u53d6\u6570\u636e\uff0crte_kni \u4e5f\u6a21\u62df\u4e86\u7f51\u5361\u9a71\u52a8\u521d\u59cb\u5316\u7684\u8fc7\u7a0b\u5e76\u6ce8\u518c ethtool_ops \u7ed3\u6784\u4f53\uff0c\u8fd9\u4e00\u90e8\u5206\u7684\u4ee3\u7801\u5728\u9ad8\u7248\u672c\u5df2\u7ecf\u88ab\u79fb\u9664\u3002\u57fa\u4e8e\u8fd9\u70b9\uff0c\u672c\u6587\u96c6\u4e2d\u53d9\u8ff0 rte_kni \u865a\u62df\u7f51\u5361\u521d\u59cb\u5316\u4e0e\u6536\u53d1\u5305\u7684\u8fc7\u7a0b\u53ca\u4e0e pmd \u4ea4\u4e92\u7684\u539f\u7406\uff0cethtool \u76f8\u5173\u4ee3\u7801\u4e0d\u5728\u672c\u6587\u7684\u63a2\u8ba8\u8303\u56f4\u5185\u3002"),(0,r.kt)("h2",{id:"rte_kni-\u6a21\u5757\u7684\u76ee\u5f55\u7ed3\u6784"},"rte_kni \u6a21\u5757\u7684\u76ee\u5f55\u7ed3\u6784"),(0,r.kt)("p",null,"rte_kni \u6a21\u5757\u76ee\u5f55\u7ed3\u6784\u5982\u4e0b\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"Makefile  compat.h  ethtool  kni_dev.h  kni_ethtool.c  kni_fifo.h  kni_misc.c  kni_net.c  kni_vhost.c\n")),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Makefile \u6587\u4ef6\u4e3a rte_kni \u7f16\u8bd1\u811a\u672c")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"compat.h \u6587\u4ef6\u7528\u4e8e\u9002\u914d\u4e0d\u540c\u7248\u672c\u5185\u6838\u7684\u4e00\u4e9b\u63a5\u53e3")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"ethtool \u76ee\u5f55\u4e2d\u5b58\u653e\u9002\u914d igb\u3001ixgbe \u7f51\u5361 ethtool \u529f\u80fd\u7684\u4ee3\u7801")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"kni_dev.h \u4e2d\u5b9a\u4e49 kni device \u7b49\u91cd\u8981\u7ed3\u6784\u4f53")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"kni_ethtool.c \u4e2d\u5b9a\u4e49 kni_ethtool_ops \u7ed3\u6784\u4f53\uff0c\u6b64\u7ed3\u6784\u4f53\u4e2d\u7684\u65b9\u6cd5\u5c01\u88c5\u4e86\u5bf9 lad_dev->ethtool_ops \u4e2d\u65b9\u6cd5\u7684\u8c03\u7528")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"kni_fifo.h \u4e2d\u5b9a\u4e49\u5171\u4eab\u961f\u5217\u7684\u521d\u59cb\u5316\u3001count\u3001get\u3001put \u63a5\u53e3")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"kni_misc.c \u4e2d\u5b9e\u73b0 kni \u5b57\u7b26\u8bbe\u5907\uff0c\u4ee5\u53ca\u64cd\u4f5c\u8fd9\u4e9b\u5b57\u7b26\u8bbe\u5907\u6587\u4ef6\u7684\u65b9\u6cd5\uff0c\u5982 open\u3001ioctl \u65b9\u6cd5\u7b49")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"kni_net.c \u4e2d\u5b9e\u73b0 kni \u865a\u62df\u7f51\u7edc\u8bbe\u5907\u9a71\u52a8")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"kni_vhost.c \u662f\u9488\u5bf9 vhost \u7684\u5b9a\u5236\uff0c\u4e0d\u5728\u672c\u6587\u63a2\u8ba8\u8303\u56f4\u5185"))),(0,r.kt)("h2",{id:"kni-\u6a21\u5757\u521d\u59cb\u5316\u8fc7\u7a0b"},"kni \u6a21\u5757\u521d\u59cb\u5316\u8fc7\u7a0b"),(0,r.kt)("p",null,"kni \u6a21\u5757\u521d\u59cb\u5316\u51fd\u6570\u4e3a kni_init\uff0c\u5176\u6e90\u7801\u5982\u4e0b\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'155 static int __init\n156 kni_init(void)\n157 {\n158     int rc;\n159\n160     KNI_PRINT("######## DPDK kni module loading ########\\n");\n161\n162     if (kni_parse_kthread_mode() < 0) {\n163         KNI_ERR("Invalid parameter for kthread_mode\\n");\n164         return -EINVAL;\n165     }\n166\n167 #if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 32)\n168     rc = register_pernet_subsys(&kni_net_ops);\n169 #else\n170     rc = register_pernet_gen_subsys(&kni_net_id, &kni_net_ops);\n171 #endif /* LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 32) */\n172     if (rc)\n173         return -EPERM;\n174\n175     rc = misc_register(&kni_misc);\n176     if (rc != 0) {\n177         KNI_ERR("Misc registration failed\\n");\n178         goto out;\n179     }\n180\n181     /* Configure the lo mode according to the input parameter */\n182     kni_net_config_lo_mode(lo_mode);\n183\n184     KNI_PRINT("######## DPDK kni module loaded  ########\\n");\n185\n186     return 0;\n187\n188 out:\n189 #if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 32)\n190     unregister_pernet_subsys(&kni_net_ops);\n191 #else\n192     register_pernet_gen_subsys(&kni_net_id, &kni_net_ops);\n193 #endif /* LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 32) */\n194     return rc;\n195 }\n')),(0,r.kt)("p",null,"\u6b64\u51fd\u6570\u9996\u5148\u89e3\u6790 kthread_mode \u6a21\u5757\u53c2\u6570\uff0c\u6839\u636e\u53c2\u6570\u8bbe\u7f6e multiple_kthread_on\u3001g_kni_net_rx \u53d8\u91cf\u7684\u503c\u3002"),(0,r.kt)("p",null,"\u6b64\u540e\u6ce8\u518c kni \u7f51\u7edc\u547d\u540d\u7a7a\u95f4\u8bbe\u5907\uff0ckni_net_ops \u4e2d\u5b9e\u4f8b\u5316\u7684 kni_init_net \u51fd\u6570\u4f1a\u5728\u6bcf\u4e2a\u7f51\u7edc\u547d\u540d\u7a7a\u95f4\u521b\u5efa\u7684\u65f6\u5019\u88ab\u8c03\u7528\uff0c\u521b\u5efa\u4e00\u4e2a kni_net \u7ed3\u6784\uff0c\u5e76\u521d\u59cb\u5316\u76f8\u5e94\u7684\u6570\u636e\u7ed3\u6784\uff0c\u7136\u540e\u6ce8\u518c\u3002"),(0,r.kt)("p",null,"\u4e0e\u6b64\u7c7b\u4f3c\uff0ckni_net_ops \u4e2d\u5b9e\u4f8b\u5316\u7684 kni_exit_net \u51fd\u6570\u5728\u6bcf\u4e2a\u7f51\u7edc\u547d\u4ee4\u7a7a\u95f4\u9500\u6bc1\u65f6\u88ab\u8c03\u7528\uff0c\u5b83\u4f1a free kni_net \u7ed3\u6784\u3002"),(0,r.kt)("p",null,"175 \u884c\u6ce8\u518c kni misc \u8bbe\u5907\uff0c\u6210\u529f\u540e\u7ee7\u7eed\u8c03\u7528 kni_net_config_lo_mode \u89e3\u6790 lo_mode \u6a21\u5757\u53c2\u6570\uff0c\u914d\u7f6e\u4e0d\u540c\u7684 kni \u6536\u5305\u51fd\u6570\uff0c\u4e0d\u592a\u5e38\u7528\uff0c\u4e0d\u8fdb\u884c\u5206\u6790\u3002"),(0,r.kt)("h2",{id:"kni-misc-\u9a71\u52a8\u7684\u539f\u7406"},"kni misc \u9a71\u52a8\u7684\u539f\u7406"),(0,r.kt)("p",null,"kni misc \u9a71\u52a8\u5b9e\u4f8b\u5316\u4e86\u4e00\u4e2a miscdevice \u7ed3\u6784\u4f53\uff0c \u6b64\u7ed3\u6784\u4f53\u4e2d\u7684 name \u5b57\u6bb5\u7528\u4e8e\u6807\u8bc6 kni misc \u9a71\u52a8\uff0cminor \u5b57\u6bb5\u6307\u5b9a\u8bbe\u5907 minor \u53f7\u52a8\u6001\u5206\u914d\uff0cfops \u8868\u793a\u7ed1\u5b9a\u5728\u6b64\u8bbe\u5907\u6587\u4ef6\u4e0a\u7684\u6587\u4ef6\u64cd\u4f5c\u65b9\u6cd5\u3002"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"kni_open \u4f1a\u5728\u6253\u5f00 /dev/kni \u6587\u4ef6\u7684\u65f6\u5019\u88ab\u8c03\u7528"),(0,r.kt)("li",{parentName:"ol"},"kni_release \u4f1a\u5728\u5173\u95ed /dev/kni \u6587\u4ef6\u7684\u65f6\u5019\u88ab\u8c03\u7528"),(0,r.kt)("li",{parentName:"ol"},"kni_ioctl \u4e0e kni_compat_ioctl \u5728\u901a\u8fc7 ioctl \u63a7\u5236 /dev/kni \u6587\u4ef6\u65f6\u88ab\u8c03\u7528")),(0,r.kt)("p",null,"\u5b9e\u4f8b\u5316\u7684\u6570\u636e\u7ed3\u6784\u5b9a\u4e49\u5982\u4e0b\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"}," 73 static struct file_operations kni_fops = {\n 74     .owner = THIS_MODULE,\n 75     .open = kni_open,\n 76     .release = kni_release,\n 77     .unlocked_ioctl = (void *)kni_ioctl,\n 78     .compat_ioctl = (void *)kni_compat_ioctl,\n 79 };\n 80 \n 81 static struct miscdevice kni_misc = {\n 82     .minor = MISC_DYNAMIC_MINOR,\n 83     .name = KNI_DEVICE,\n 84     .fops = &kni_fops,\n 85 };\n")),(0,r.kt)("p",null,"kni misc \u8bbe\u5907\u4f7f\u7528\u65f6\uff0c\u7528\u6237\u6001\u7a0b\u5e8f\u9996\u5148 open /dev/kni\uff0c\u7136\u540e\u6267\u884c ioctl \u5e76\u4f20\u9012 RTE_KNI_IOCTL_CREATE \u9009\u9879\u521b\u5efa kni \u865a\u62df\u63a5\u53e3\uff0c\u7136\u540e\u6b63\u5e38\u8fd0\u884c\uff0c\u9000\u51fa\u524d\u7ee7\u7eed\u8c03\u7528 ioctl \u5e76\u4f20\u9012 RTE_KNI_IOCTL_RELEASE \u91ca\u653e kni \u865a\u62df\u63a5\u53e3\uff0c\u6700\u540e\u8c03\u7528 close /dev/kni \u6765\u91ca\u653e kni \u8bbe\u5907\u3002"),(0,r.kt)("h3",{id:"kni_open"},"kni_open"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'231 static int\n232 kni_open(struct inode *inode, struct file *file)\n233 {\n234     struct net *net = current->nsproxy->net_ns;\n235     struct kni_net *knet = net_generic(net, kni_net_id);\n236 \n237     /* kni device can be opened by one user only per netns */\n238     if (test_and_set_bit(KNI_DEV_IN_USE_BIT_NUM, &knet->device_in_use))\n239         return -EBUSY;\n240 \n241     /* Create kernel thread for single mode */\n242     if (multiple_kthread_on == 0) {\n243         KNI_PRINT("Single kernel thread for all KNI devices\\n");\n244         /* Create kernel thread for RX */\n245         knet->kni_kthread = kthread_run(kni_thread_single, (void *)knet,\n246                         "kni_single");\n247         if (IS_ERR(knet->kni_kthread)) {\n248             KNI_ERR("Unable to create kernel threaed\\n");\n249             return PTR_ERR(knet->kni_kthread);\n250         }\n251     } else\n252         KNI_PRINT("Multiple kernel thread mode enabled\\n");\n253 \n254     file->private_data = get_net(net);\n255     KNI_PRINT("/dev/kni opened\\n");\n256 \n257     return 0;\n258 }\n')),(0,r.kt)("p",null,"238 \u884c\u9996\u5148\u5224\u65ad kni_net \u7ed3\u6784\u4f53\u4e2d\u7684 device_in_use \u5b57\u6bb5\u7684\u503c\uff0c\u786e\u4fdd\u6bcf\u4e00\u4e2a\u547d\u540d\u7a7a\u95f4\u5185\u53ea\u88ab\u4e00\u4e2a\u7528\u6237\u5360\u7528\u3002"),(0,r.kt)("p",null,"241~252 \u884c\u521b\u5efa kni \u5185\u6838\u6001\u7ebf\u7a0b\uff0c\u6b64\u7ebf\u7a0b\u7528\u4e8e kni \u6536\u5305\uff0ckthread_run \u51fd\u6570\u8fd4\u56de\u7684\u7ebf\u7a0b\u63cf\u8ff0\u7b26\u5b58\u50a8\u5230 kni_net \u7ed3\u6784\u4f53\u4e2d\u7684 kni_thread \u5b57\u6bb5\u4e2d\u3002"),(0,r.kt)("p",null,"254 \u884c\u5c06 kni net \u7ed3\u6784\u4f53\u5730\u5740\u5b58\u50a8\u5230\u5f53\u524d\u8fdb\u7a0b file \u7ed3\u6784\u7684 private_data \u5b57\u6bb5\u4e2d\uff0c\u6b64\u5b57\u6bb5\u5728 kni_release \u4e2d\u88ab\u8bbf\u95ee\uff0ckni_release \u901a\u8fc7\u83b7\u53d6\u5230 file \u7ed3\u6784\u4e2d\u9884\u5148\u5b58\u50a8\u7684 kni net \u7ed3\u6784\u6765\u91ca\u653e\u521b\u5efa\u7684\u5185\u6838\u7ebf\u7a0b\u4e0e kni \u865a\u62df\u63a5\u53e3\uff0c\u91ca\u653e\u5b8c\u6210\u540e\u6e05\u9664 kni_net \u7ed3\u6784\u4e2d\u7684 device_in_use \u5b57\u6bb5\u8868\u793a\u6b64 kni \u8bbe\u5907\u7a7a\u95f2\u3002"),(0,r.kt)("p",null,"kni_release \u51fd\u6570\u4ee3\u7801\u5982\u4e0b\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'254 static int\n255 kni_release(struct inode *inode, struct file *file)\n256 {\n257     struct net *net = file->private_data;\n258     struct kni_net *knet = net_generic(net, kni_net_id);\n259     struct kni_dev *dev, *n;\n260 \n261     /* Stop kernel thread for single mode */                                                                                                                             \n262     if (multiple_kthread_on == 0) {\n263         /* Stop kernel thread */\n264         kthread_stop(knet->kni_kthread);\n265         knet->kni_kthread = NULL;\n266     }\n267 \n268     down_write(&knet->kni_list_lock);\n269     list_for_each_entry_safe(dev, n, &knet->kni_list_head, list) {\n270         /* Stop kernel thread for multiple mode */\n271         if (multiple_kthread_on && dev->pthread != NULL) {\n272             kthread_stop(dev->pthread);\n273             dev->pthread = NULL;\n274         }\n275 \n276 #ifdef RTE_KNI_VHOST\n277         kni_vhost_backend_release(dev);\n278 #endif\n279         kni_dev_remove(dev);\n280         list_del(&dev->list);\n281     }\n282     up_write(&knet->kni_list_lock);\n283 \n284     /* Clear the bit of device in use */\n285     clear_bit(KNI_DEV_IN_USE_BIT_NUM, &knet->device_in_use);\n286 \n287     put_net(net);\n288     KNI_PRINT("/dev/kni closed\\n");\n289 \n290     return 0;\n291 }\n')),(0,r.kt)("h3",{id:"kni_ioctl-\u51fd\u6570"},"kni_ioctl \u51fd\u6570"),(0,r.kt)("p",null,"kni_ioctl \u51fd\u6570\u63a7\u5236 kni \u865a\u62df\u7f51\u5361\u63a5\u53e3\u7684\u521b\u5efa\u4e0e\u6ce8\u9500\u8fc7\u7a0b\uff0c\u5176\u4ee3\u7801\u5982\u4e0b\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'628 static int\n629 kni_ioctl(struct inode *inode,\n630     unsigned int ioctl_num,\n631     unsigned long ioctl_param)\n632 {\n633     int ret = -EINVAL;\n634     struct net *net = current->nsproxy->net_ns;\n635 \n636     KNI_DBG("IOCTL num=0x%0x param=0x%0lx\\n", ioctl_num, ioctl_param);\n637 \n638     /*\n639      * Switch according to the ioctl called\n640      */\n641     switch (_IOC_NR(ioctl_num)) {\n642     case _IOC_NR(RTE_KNI_IOCTL_TEST):\n643         /* For test only, not used */\n644         break;\n645     case _IOC_NR(RTE_KNI_IOCTL_CREATE):\n646         ret = kni_ioctl_create(net, ioctl_num, ioctl_param);\n647         break;\n648     case _IOC_NR(RTE_KNI_IOCTL_RELEASE):\n649         ret = kni_ioctl_release(net, ioctl_num, ioctl_param);\n650         break;\n651     default:\n652         KNI_DBG("IOCTL default\\n");\n653         break;\n654     }\n655 \n656     return ret;\n657 }\n')),(0,r.kt)("p",null,"\u5b83\u6839\u636e ioctl_num \u6765\u5206\u53d1\u5904\u7406\u903b\u8f91\uff0cRTE_KNI_IOCTL_TEST \u4ec5\u7528\u4e8e\u6d4b\u8bd5\uff0c\u4e0d\u6267\u884c\u4efb\u4f55\u903b\u8f91\uff0cRTE_KNI_IOCTL_CREATE\u3001RTE_KNI_IOCTL_RELEASE \u5206\u522b\u7528\u4e8e\u521b\u5efa\u3001\u9500\u6bc1 kni \u865a\u62df\u7f51\u5361\u3002"),(0,r.kt)("h3",{id:"kni_ioctl_create-\u51fd\u6570"},"kni_ioctl_create \u51fd\u6570"),(0,r.kt)("p",null,"kni_ioctl_create \u51fd\u6570\u4ee3\u7801\u5982\u4e0b\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'389 static int\n390 kni_ioctl_create(struct net *net,\n391         unsigned int ioctl_num, unsigned long ioctl_param)\n392 {\n393     struct kni_net *knet = net_generic(net, kni_net_id);\n394     int ret;\n395     struct rte_kni_device_info dev_info;\n396     struct pci_dev *pci = NULL;\n397     struct pci_dev *found_pci = NULL;\n398     struct net_device *net_dev = NULL;\n399     struct net_device *lad_dev = NULL;\n400     struct kni_dev *kni, *dev, *n;\n401 \n402     printk(KERN_INFO "KNI: Creating kni...\\n");\n403     /* Check the buffer size, to avoid warning */\n404     if (_IOC_SIZE(ioctl_num) > sizeof(dev_info))\n405         return -EINVAL;\n406 \n407     /* Copy kni info from user space */\n408     ret = copy_from_user(&dev_info, (void *)ioctl_param, sizeof(dev_info));\n409     if (ret) {\n410         KNI_ERR("copy_from_user in kni_ioctl_create");\n411         return -EIO;\n412     }\n413 \n414     /**\n415      * Check if the cpu core id is valid for binding,\n416      * for multiple kernel thread mode.\n417      */\n418     if (multiple_kthread_on && dev_info.force_bind &&\n419                 !cpu_online(dev_info.core_id)) {\n420         KNI_ERR("cpu %u is not online\\n", dev_info.core_id);\n421         return -EINVAL;\n422     }\n423 \n424     /* Check if it has been created */\n425     down_read(&knet->kni_list_lock);\n426     list_for_each_entry_safe(dev, n, &knet->kni_list_head, list) {\n427         if (kni_check_param(dev, &dev_info) < 0) {\n428             up_read(&knet->kni_list_lock);\n429             return -EINVAL;\n430         }\n431     }\n432     up_read(&knet->kni_list_lock);\n433 \n434     net_dev = alloc_netdev(sizeof(struct kni_dev), dev_info.name,\n435 #ifdef NET_NAME_UNKNOWN\n436                             NET_NAME_UNKNOWN,\n437 #endif\n438                             kni_net_init);\n439     if (net_dev == NULL) {\n440         KNI_ERR("error allocating device \\"%s\\"\\n", dev_info.name);\n441         return -EBUSY;\n442     }\n443 \n444     dev_net_set(net_dev, net);\n445 \n446     kni = netdev_priv(net_dev);\n447 \n448     kni->net_dev = net_dev;\n449     kni->group_id = dev_info.group_id;\n450     kni->core_id = dev_info.core_id;\n451     strncpy(kni->name, dev_info.name, RTE_KNI_NAMESIZE);\n452 \n453     /* Translate user space info into kernel space info */\n454     kni->tx_q = phys_to_virt(dev_info.tx_phys);\n455     kni->rx_q = phys_to_virt(dev_info.rx_phys);\n456     kni->alloc_q = phys_to_virt(dev_info.alloc_phys);\n457     kni->free_q = phys_to_virt(dev_info.free_phys);\n459     kni->req_q = phys_to_virt(dev_info.req_phys);\n460     kni->resp_q = phys_to_virt(dev_info.resp_phys);\n461     kni->sync_va = dev_info.sync_va;\n462     kni->sync_kva = phys_to_virt(dev_info.sync_phys);\n463 \n464     kni->mbuf_kva = phys_to_virt(dev_info.mbuf_phys);\n465     kni->mbuf_va = dev_info.mbuf_va;\n466 \n467 #ifdef RTE_KNI_VHOST\n468     kni->vhost_queue = NULL;\n469     kni->vq_status = BE_STOP;\n470 #endif\n471     kni->mbuf_size = dev_info.mbuf_size;\n472 \n.............................................................. \n497     pci = pci_get_device(dev_info.vendor_id, dev_info.device_id, NULL);\n499     /* Support Ethtool */\n500     while (pci) {\n501         KNI_PRINT("pci_bus: %02x:%02x:%02x \\n",\n502                     pci->bus->number,\n503                     PCI_SLOT(pci->devfn),\n504                     PCI_FUNC(pci->devfn));\n505 \n506         if ((pci->bus->number == dev_info.bus) &&\n507             (PCI_SLOT(pci->devfn) == dev_info.devid) &&\n508             (PCI_FUNC(pci->devfn) == dev_info.function)) {\n509             found_pci = pci;\n510             switch (dev_info.device_id) {\n511             #define RTE_PCI_DEV_ID_DECL_IGB(vend, dev) case (dev):\n512             #include <rte_pci_dev_ids.h>\n513                 ret = igb_kni_probe(found_pci, &lad_dev);\n514                 break;\n.................................................................\n520             default:\n521                 ret = -1;\n522                 break;\n523             }\n524 \n525             KNI_DBG("PCI found: pci=0x%p, lad_dev=0x%p\\n",\n526                             pci, lad_dev);\n527             if (ret == 0) {\n528                 kni->lad_dev = lad_dev;\n529                 kni_set_ethtool_ops(kni->net_dev);\n530             } else {\n531                 KNI_ERR("Device not supported by ethtool");\n532                 kni->lad_dev = NULL;\n533             }\n534 \n535             kni->pci_dev = found_pci;\n536             kni->device_id = dev_info.device_id;\n537             break;\n538         }\n539         pci = pci_get_device(dev_info.vendor_id,\n540                 dev_info.device_id, pci);\n541     }                                                                                                                                                                    \n542     if (pci)\n543         pci_dev_put(pci);\n544 \n545     ret = register_netdev(net_dev);\n546     if (ret) {\n547         KNI_ERR("error %i registering device \\"%s\\"\\n",\n548                     ret, dev_info.name);\n549         kni_dev_remove(kni);\n550         return -ENODEV;\n551     }\n552 \n553 #ifdef RTE_KNI_VHOST\n554     kni_vhost_init(kni);\n555 #endif\n556 \n557     /**\n558      * Create a new kernel thread for multiple mode, set its core affinity,\n559      * and finally wake it up.\n560      */\n561     if (multiple_kthread_on) {\n562         kni->pthread = kthread_create(kni_thread_multiple,\n563                           (void *)kni,\n564                           "kni_%s", kni->name);\n565         if (IS_ERR(kni->pthread)) {\n566             kni_dev_remove(kni);\n567             return -ECANCELED;\n568         }\n569         if (dev_info.force_bind)\n570             kthread_bind(kni->pthread, kni->core_id);\n571         wake_up_process(kni->pthread);\n572     }\n573 \n574     down_write(&knet->kni_list_lock);\n575     list_add(&kni->list, &knet->kni_list_head);\n576     up_write(&knet->kni_list_lock);\n577 \n578     return 0;\n579 }\n')),(0,r.kt)("p",null,"kni_ioctl_create \u4e3b\u8981\u903b\u8f91\u5982\u4e0b\uff1a"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"\u4ece\u7528\u6237\u6001\u62f7\u8d1d rte_kni_device_info \u7ed3\u6784\uff0c\u586b\u5145\u5230 dev_info \u4e2d"),(0,r.kt)("li",{parentName:"ol"},"\u5224\u65ad multiple_thread \u6a21\u5f0f\u662f\u5426\u5f00\u542f\uff0c\u5f00\u542f\u65f6\u5219\u5f53\u8bbe\u5b9a\u4e86 dev_info \u7684 force_bind \u9009\u9879\u540e\u68c0\u67e5 dev_info \u4e2d\u8bbe\u5b9a\u7684 core_id \u662f\u5426\u5408\u6cd5\uff0c\u4e0d\u5408\u6cd5\u5219\u7acb\u5373\u8fd4\u56de"),(0,r.kt)("li",{parentName:"ol"},"\u83b7\u53d6 kni_net \u7ed3\u6784\u4e2d kni_list_lock \u4fe1\u53f7\u91cf\uff0c\u904d\u5386 kni_net \u7684 kni_list_head \u94fe\u8868\uff0c\u68c0\u67e5\u5f85\u521b\u5efa\u7684\u63a5\u53e3\u662f\u5426\u5df2\u7ecf\u88ab\u521b\u5efa\u8fc7\uff0c\u662f\u5219\u91ca\u653e\u4fe1\u53f7\u91cf\u5e76\u8fd4\u56de"),(0,r.kt)("li",{parentName:"ol"},"\u91ca\u653e\u4fe1\u53f7\u91cf\u5e76\u8c03\u7528 alloc_netdev \u521b\u5efa\u4e00\u4e2a kni_net  netdev \u63a5\u53e3\uff0cdev_info \u7684 name \u5b57\u6bb5\u4e3a netdev \u7684\u540d\u79f0\uff0ckni_net_init \u7528\u4e8e\u521d\u59cb\u5316\u6b64 netdev \u7ed3\u6784\u4e2d kni \u7684\u79c1\u6709\u53d8\u91cf"),(0,r.kt)("li",{parentName:"ol"},"\u5efa\u7acb kni netdev \u7ed3\u6784\u4e0e net \u7ed3\u6784\u7684\u5173\u8054\uff0c\u586b\u5145 kni_dev \u4e2d\u7684\u5b57\u6bb5\uff0c\u586b\u5145 txq\u3001rxq \u7b49\u5171\u4eab fifo \u5730\u5740\u65f6\u8c03\u7528 phys_to_virt \u5c06\u7269\u7406\u5730\u5740\u8f6c\u5316\u4e3a\u5185\u6838\u7684\u865a\u62df\u5730\u5740\u4f7f\u7528"),(0,r.kt)("li",{parentName:"ol"},"\u5faa\u73af\u8c03\u7528 pci_get_device \u4f9d\u6b21\u904d\u5386 pci \u8bbe\u5907\uff0c\u5f53 pci \u53f7\u4e0e dev_info \u4e2d\u914d\u7f6e\u7684 pci \u53f7\u4e00\u81f4\u65f6\uff0c\u6839\u636e device id \u6765\u9009\u62e9 probe \u51fd\u6570"),(0,r.kt)("li",{parentName:"ol"},"device id \u4e0e rte_pci_dev_ids.h \u4e2d\u5b9a\u4e49\u7684 igb\u3001ixgbe \u7f51\u5361\u5339\u914d\u65f6\uff0c\u8c03\u7528 igb_kni_probe\u3001ixgbe_kni_probe \u63a5\u53e3\u5b8c\u6210\u7c7b\u4f3c\u7f51\u5361\u9a71\u52a8 probe \u7684\u8fc7\u7a0b\uff0c\u6b63\u5e38 probe \u4f1a\u7ee7\u7eed\u521b\u5efa\u4e00\u4e2a netdev \u7ed3\u6784\uff0c\u6b64\u7ed3\u6784\u88ab\u5b58\u50a8\u5230 lad_dev \u4e2d\u8fd4\u56de\uff0c\u6b64 lad_dev \u7684\u503c\u6700\u7ec8\u88ab\u4fdd\u5b58\u5230 kni_net \u7ed3\u6784\u4e2d\u7684 lad_dev \u5b57\u6bb5\u4e2d\uff0cprobe \u6210\u529f\u540e\uff0ckni \u4f1a\u8bbe\u5b9a kni_net \u4e2d net_dev \u7684 ethtool_ops \u5b57\u6bb5\uff0c\u6b64\u5b57\u6bb5\u5c01\u88c5\u4e86\u5bf9 lad_dev->ethtool_ops \u4e2d\u65b9\u6cd5\u7684\u8c03\u7528\u3002\u7f51\u5361\u4e0d\u652f\u6301 ethtool \u7684\u65f6\u5019 lad_dev \u4e3a\u7a7a"),(0,r.kt)("li",{parentName:"ol"},"\u5f53 pci \u6709\u6548\u65f6\uff0c\u8c03\u7528 pci_dev_put \u91ca\u653e pci "),(0,r.kt)("li",{parentName:"ol"},"\u8c03\u7528 register_netdev \u6ce8\u518c kni net_device \u7ed3\u6784\uff0c\u5931\u8d25\u5219\u8c03\u7528 kni_dev_remove \u79fb\u9664\u865a\u62df\u63a5\u53e3"),(0,r.kt)("li",{parentName:"ol"},"multiple_thread \u6a21\u5f0f\u5f00\u542f\u540e\uff0c\u521b\u5efa\u56de\u8c03\u51fd\u6570\u4e3a kni_thread_multiple  \u7684\u5185\u6838\u7ebf\u7a0b\u5e76\u5728 dev_info \u4e2d\u7684 force_bind \u5b57\u6bb5\u8bbe\u5b9a\u65f6\uff0c\u7ed1\u5b9a\u7ebf\u7a0b\u5230\u6307\u5b9a\u7684\u6838\u4e0a"),(0,r.kt)("li",{parentName:"ol"},"\u83b7\u53d6 kni_net \u7ed3\u6784\u4e2d\u7684 kni_list_lock \u4fe1\u53f7\u91cf\uff0c\u6ce8\u518c kni \u8bbe\u5907\u5230 kni_list_head \u94fe\u8868\u4e2d\uff0c\u6700\u540e\u91ca\u653e\u4fe1\u53f7\u91cf")),(0,r.kt)("p",null,"kni \u5728\u904d\u5386 pci \u5217\u8868\u5e76 probe \u9a71\u52a8\u7684\u65f6\u5019\uff0c\u4f7f\u7528\u4e86\u4e00\u4e2a\u6280\u5de7\uff0c\u5b83\u5728 probe igb \u7f51\u5361\u65f6\u4f7f\u7528\u7684\u4ee3\u7801\u5982\u4e0b\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"511             #define RTE_PCI_DEV_ID_DECL_IGB(vend, dev) case (dev):\n512             #include <rte_pci_dev_ids.h>\n513                 ret = igb_kni_probe(found_pci, &lad_dev);\n")),(0,r.kt)("p",null,"\u9996\u5148\u5b9a\u4e49\u4e86\u4e00\u4e2a RTE_PCI_DEV_ID_DECL_IGB \u5b8f\uff0c\u6b64\u5b8f\u4f7f\u7528 dev \u53c2\u6570\uff0c\u9884\u5904\u7406\u540e\u5219\u4e3a case (0201): \u8fd9\u79cd\u683c\u5f0f\uff0c\u5b83\u6b63\u597d\u662f\u4e00\u4e2a\u4ee5\u8bbe\u5907 id \u4e3a\u6761\u4ef6\u7684 case \u9009\u9879\uff0c\u5305\u542b\u4e86 rte_pci_dev_ids.h \u540e\uff0c\u6240\u6709\u7684\u652f\u6301\u7684 igb \u7f51\u5361\u90fd\u4f1a\u751f\u6210\u76f8\u5173\u7684 case\uff0c\u800c\u8fd9\u4e9b case \u7684\u4e3b\u4f53\u51fd\u6570\u90fd\u662f igb_kni_probe\uff0c\u8fd9\u5c31\u662f\u8fd9\u91cc\u7684\u673a\u5173\u3002"),(0,r.kt)("h2",{id:"rte_kni-\u865a\u62df\u7f51\u7edc\u63a5\u53e3\u7684\u6536\u5305\u51fd\u6570"},"rte_kni \u865a\u62df\u7f51\u7edc\u63a5\u53e3\u7684\u6536\u5305\u51fd\u6570"),(0,r.kt)("p",null,"rte_kni \u521b\u5efa\u7684\u865a\u62df\u7f51\u7edc\u63a5\u53e3\u652f\u6301\u591a\u4e2a\u6536\u5305\u51fd\u6570\uff0c\u4e0b\u9762\u6211\u4ee5 kni_net_rx_normal \u8fd9\u4e2a\u666e\u901a\u7684\u51fd\u6570\u4e3a\u4f8b\uff0c\u63a2\u8ba8\u8fd9\u91cc\u7684\u8fc7\u7a0b\u3002"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'128 static void\n129 kni_net_rx_normal(struct kni_dev *kni)\n130 {\n131     unsigned ret;\n132     uint32_t len;\n133     unsigned i, num_rx, num_fq;\n134     struct rte_kni_mbuf *kva;\n135     struct rte_kni_mbuf *va[MBUF_BURST_SZ];\n136     void * data_kva;\n137 \n138     struct sk_buff *skb;\n139     struct net_device *dev = kni->net_dev;\n140 \n141     /* Get the number of free entries in free_q */\n142     num_fq = kni_fifo_free_count(kni->free_q);\n143     if (num_fq == 0) {\n144         /* No room on the free_q, bail out */\n145         return;\n146     }\n147 \n148     /* Calculate the number of entries to dequeue from rx_q */\n149     num_rx = min(num_fq, (unsigned)MBUF_BURST_SZ);\n150 \n151     /* Burst dequeue from rx_q */\n152     num_rx = kni_fifo_get(kni->rx_q, (void **)va, num_rx);\n153     if (num_rx == 0)\n154         return;\n155 \n156     /* Transfer received packets to netif */\n157     for (i = 0; i < num_rx; i++) {\n158         kva = (void *)va[i] - kni->mbuf_va + kni->mbuf_kva;\n159         len = kva->data_len;\n160         data_kva = kva->buf_addr + kva->data_off - kni->mbuf_va\n161                 + kni->mbuf_kva;\n162 \n163         skb = dev_alloc_skb(len + 2);\n164         if (!skb) {\n165             KNI_ERR("Out of mem, dropping pkts\\n");\n166             /* Update statistics */\n167             kni->stats.rx_dropped++;\n168         }\n169         else {\n170             /* Align IP on 16B boundary */\n171             skb_reserve(skb, 2);\n172             memcpy(skb_put(skb, len), data_kva, len);\n173             skb->dev = dev;\n174             skb->protocol = eth_type_trans(skb, dev);\n175             skb->ip_summed = CHECKSUM_UNNECESSARY;\n176 \n177             /* Call netif interface */\n178             netif_rx_ni(skb);\n179 \n180             /* Update statistics */\n181             kni->stats.rx_bytes += len;\n182             kni->stats.rx_packets++;\n183         }\n184     }\n185 \n186     /* Burst enqueue mbufs into free_q */\n187     ret = kni_fifo_put(kni->free_q, (void **)va, num_rx);\n188     if (ret != num_rx)\n189         /* Failing should not happen */\n190         KNI_ERR("Fail to enqueue entries into free_q\\n");\n191 }\n\n')),(0,r.kt)("p",null,"\u6b64\u51fd\u6570\u7684\u4e3b\u8981\u903b\u8f91\u5982\u4e0b\uff1a"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"\u5224\u65ad free_q \u4e2d\u662f\u5426\u6709\u7a7a\u95f4\uff0c\u65e0\u5219\u76f4\u63a5\u8fd4\u56de\uff0c\u6709\u5219\u7ee7\u7eed\u4e0b\u4e00\u6b65"),(0,r.kt)("li",{parentName:"ol"},"\u786e\u5b9a\u80fd\u591f\u4ece rx_q \u4e2d\u51fa\u961f\u5217\u7684\u6570\u76ee\uff0c\u6b64\u6570\u76ee\u662f free_q \u4e2d\u7684\u7a7a\u95f2\u6570\u76ee\u4e0e burst \u5927\u5c0f\u7684\u6700\u5c0f\u503c"),(0,r.kt)("li",{parentName:"ol"},"\u8c03\u7528 kni_fifo_get \u4ece rx_q \u961f\u5217\u4e2d\u83b7\u53d6 num_rx \u4e2a mbuf \u7684\u5730\u5740\uff0c\u6570\u91cf\u4e3a 0 \u5219\u8fd4\u56de"),(0,r.kt)("li",{parentName:"ol"},"\u5bf9\u4e8e\u6bcf\u4e2a\u51fa\u961f\u5217\u7684 mbuf\uff0c\u521b\u5efa sk_buff \u7ed3\u6784\uff0c\u590d\u5236 mbuf \u4e2d\u7684\u62a5\u6587\u5230 sk_buff \u4e2d\u5e76\u586b\u5145\u76f8\u5173\u7684\u5b57\u6bb5\uff0c\u901a\u8fc7 netif_rx_ni \u6295\u9012\u5230\u5185\u6838\u534f\u8bae\u6808\u5e76\u589e\u52a0 kni \u5185\u90e8\u7edf\u8ba1"),(0,r.kt)("li",{parentName:"ol"},"\u5c06 mbuf \u91ca\u653e\u5230 free_q \u961f\u5217\u4e2d")),(0,r.kt)("h2",{id:"rte_kni-\u865a\u62df\u7f51\u7edc\u63a5\u53e3\u7684\u53d1\u5305\u51fd\u6570"},"rte_kni \u865a\u62df\u7f51\u7edc\u63a5\u53e3\u7684\u53d1\u5305\u51fd\u6570"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'390 static int\n391 kni_net_tx(struct sk_buff *skb, struct net_device *dev)\n392 {\n393     int len = 0;\n394     unsigned ret;\n395     struct kni_dev *kni = netdev_priv(dev);\n396     struct rte_kni_mbuf *pkt_kva = NULL;\n397     struct rte_kni_mbuf *pkt_va = NULL;\n398 \n399     dev->trans_start = jiffies; /* save the timestamp */\n400 \n401     /* Check if the length of skb is less than mbuf size */\n402     if (skb->len > kni->mbuf_size)\n403         goto drop;\n404 \n405     /**\n406      * Check if it has at least one free entry in tx_q and\n407      * one entry in alloc_q.\n408      */\n409     if (kni_fifo_free_count(kni->tx_q) == 0 ||\n410             kni_fifo_count(kni->alloc_q) == 0) {\n411         /**\n412          * If no free entry in tx_q or no entry in alloc_q,\n413          * drops skb and goes out.\n414          */\n415         goto drop;\n416     }\n417 \n418     /* dequeue a mbuf from alloc_q */\n419     ret = kni_fifo_get(kni->alloc_q, (void **)&pkt_va, 1);\n420     if (likely(ret == 1)) {\n421         void *data_kva;\n422 \n423         pkt_kva = (void *)pkt_va - kni->mbuf_va + kni->mbuf_kva;\n424         data_kva = pkt_kva->buf_addr + pkt_kva->data_off - kni->mbuf_va\n425                 + kni->mbuf_kva;\n426 \n427         len = skb->len;\n428         memcpy(data_kva, skb->data, len);\n429         if (unlikely(len < ETH_ZLEN)) {\n430             memset(data_kva + len, 0, ETH_ZLEN - len);           \n431             len = ETH_ZLEN;\n432         }\n433         pkt_kva->pkt_len = len;\n434         pkt_kva->data_len = len;\n435 \n436         /* enqueue mbuf into tx_q */\n437         ret = kni_fifo_put(kni->tx_q, (void **)&pkt_va, 1);\n438         if (unlikely(ret != 1)) {\n439             /* Failing should not happen */\n440             KNI_ERR("Fail to enqueue mbuf into tx_q\\n");\n441             goto drop;\n442         }\n443     } else {\n444         /* Failing should not happen */\n445         KNI_ERR("Fail to dequeue mbuf from alloc_q\\n");\n446         goto drop;\n447     }\n448 \n449     /* Free skb and update statistics */\n450     dev_kfree_skb(skb);\n451     kni->stats.tx_bytes += len;\n452     kni->stats.tx_packets++;\n453 \n454     return NETDEV_TX_OK;\n455 \n456 drop:\n457     /* Free skb and update statistics */\n458     dev_kfree_skb(skb);\n459     kni->stats.tx_dropped++;\n460 \n461     return NETDEV_TX_OK;\n462 }\n')),(0,r.kt)("p",null,"\u5f53\u5185\u6838\u534f\u8bae\u6808\u8981\u901a\u8fc7 kni \u63a5\u53e3\u53d1\u5305\u65f6\uff0c\u4f1a\u8c03\u7528\u5230 kni_net_tx \u51fd\u6570\uff0c\u6b64\u51fd\u6570\u7684\u4e3b\u8981\u903b\u8f91\u5982\u4e0b\uff1a"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"\u5224\u65ad alloc_q \u4e0e tx_q \u4e2d\u662f\u5426\u6709\u7a7a\u95f2\u9879\u76ee\uff0c\u65e0\u7a7a\u95f2\u9879\u76ee\u5219\u4e22\u5f03 sk_buff \u5e76\u589e\u52a0\u7edf\u8ba1"),(0,r.kt)("li",{parentName:"ol"},"\u4ece alloc_q \u4e2d\u83b7\u53d6\u4e00\u4e2a mbuf \u5730\u5740\uff0c\u83b7\u53d6\u5931\u8d25\u5219\u4e22\u5f03 sk_buff \u5e76\u589e\u52a0\u7edf\u8ba1"),(0,r.kt)("li",{parentName:"ol"},"\u83b7\u53d6\u5230 mbuf \u5730\u5740\u540e\u5c06 sk_buff \u4e2d\u7684\u62a5\u6587\u586b\u5145\u5230 mbuf \u4e2d\u7136\u540e\u653e\u5230 tx_q \u961f\u5217\u4e2d"),(0,r.kt)("li",{parentName:"ol"},"\u91ca\u653e sk_buff \u7ed3\u6784\u5e76\u589e\u52a0\u7edf\u8ba1")),(0,r.kt)("h2",{id:"rte_kni-\u865a\u62df\u63a5\u53e3\u6536\u53d1\u5305\u4e2d-mbuf-\u7684\u6d41\u52a8\u8fc7\u7a0b"},"rte_kni \u865a\u62df\u63a5\u53e3\u6536\u53d1\u5305\u4e2d mbuf \u7684\u6d41\u52a8\u8fc7\u7a0b"),(0,r.kt)("p",null,"\u4e0b\u56fe\u5f62\u8c61\u7684\u8868\u793a\u51fa\u4e86 kni \u865a\u62df\u63a5\u53e3\u6536\u53d1\u8fc7\u7a0b\u4e2d mbuf \u7684\u6d41\u52a8\uff0c\u6458\u81ea dpdk \u5b98\u7f51\uff1a\n",(0,r.kt)("img",{parentName:"p",src:"https://img-blog.csdnimg.cn/20210422084914778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xvbmd5dV93bHo=,size_16,color_FFFFFF,t_70",alt:"\u5728\u8fd9\u91cc\u63d2\u5165\u56fe\u7247\u63cf\u8ff0"})),(0,r.kt)("p",null,"\u53ef\u4ee5\u53c2\u8003 ",(0,r.kt)("a",{parentName:"p",href:"https://blog.csdn.net/Longyu_wlz/article/details/115918403?spm=1001.2014.3001.5501"},"dpdk-16.04 kni \u793a\u4f8b\u7a0b\u5e8f\u5206\u6790")," \u6765\u5b66\u4e60\u3002"),(0,r.kt)("h2",{id:"\u91ca\u653e-kni-\u865a\u62df\u63a5\u53e3\u7684\u8fc7\u7a0b"},"\u91ca\u653e kni \u865a\u62df\u63a5\u53e3\u7684\u8fc7\u7a0b"),(0,r.kt)("p",null,"\u91ca\u653e kni \u865a\u62df\u63a5\u53e3\u65f6\uff0c\u7528\u6237\u6001\u7a0b\u5e8f\u8c03\u7528 ioctl \u5e76\u4f20\u9012 RTE_KNI_IOCTL_RELEASE \u53c2\u6570\uff0c\u5185\u6838\u6001\u4e2d\u4f1a\u8c03\u7528 kni_ioctl_release \u51fd\u6570\uff0c\u6b64\u51fd\u6570\u4ee3\u7801\u5982\u4e0b\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'581 static int\n582 kni_ioctl_release(struct net *net,\n583         unsigned int ioctl_num, unsigned long ioctl_param)\n584 {\n585     struct kni_net *knet = net_generic(net, kni_net_id);\n586     int ret = -EINVAL;\n587     struct kni_dev *dev, *n;\n588     struct rte_kni_device_info dev_info;\n589 \n590     if (_IOC_SIZE(ioctl_num) > sizeof(dev_info))\n591             return -EINVAL;\n592 \n593     ret = copy_from_user(&dev_info, (void *)ioctl_param, sizeof(dev_info));\n594     if (ret) {\n595         KNI_ERR("copy_from_user in kni_ioctl_release");\n596         return -EIO;\n597     }\n598 \n599     /* Release the network device according to its name */\n600     if (strlen(dev_info.name) == 0)\n601         return ret;\n602 \n603     down_write(&knet->kni_list_lock);\n604     list_for_each_entry_safe(dev, n, &knet->kni_list_head, list) {\n605         if (strncmp(dev->name, dev_info.name, RTE_KNI_NAMESIZE) != 0)\n606             continue;\n607 \n608         if (multiple_kthread_on && dev->pthread != NULL) {\n609             kthread_stop(dev->pthread);\n610             dev->pthread = NULL;\n611         }\n612 \n613 #ifdef RTE_KNI_VHOST\n614         kni_vhost_backend_release(dev);\n615 #endif\n616         kni_dev_remove(dev);\n617         list_del(&dev->list);\n618         ret = 0;\n619         break;\n620     }\n621     up_write(&knet->kni_list_lock);\n622     printk(KERN_INFO "KNI: %s release kni named %s\\n",\n623         (ret == 0 ? "Successfully" : "Unsuccessfully"), dev_info.name);\n624         \n625     return ret;\n626 }\n')),(0,r.kt)("p",null,"\u6b64\u51fd\u6570\u7684\u4e3b\u8981\u903b\u8f91\u5982\u4e0b\uff1a"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"\u4ece\u7528\u6237\u6001\u590d\u5236\u53c2\u6570\u5230 dev_info \u7ed3\u6784\u4f53\u4e2d"),(0,r.kt)("li",{parentName:"ol"},"\u83b7\u53d6 kni_net \u7ed3\u6784\u4f53\u7684 kni_list_lock \u4fe1\u53f7\u91cf\uff0c\u904d\u5386 kni_list_head \u94fe\u8868\uff0c\u4f7f\u7528 dev_info.name \u6765\u5339\u914d\uff0c\u5339\u914d\u6210\u529f\u540e\u91ca\u653e kni \u8bbe\u5907\u4e2d\u521b\u5efa\u7684\u5185\u6838\u7ebf\u7a0b\uff0c\u8c03\u7528 kni_dev_remove \u6267\u884c\u7f51\u5361\u76f8\u5173\u6570\u636e\u7ed3\u6784\u7684\u91ca\u653e\u8fc7\u7a0b"),(0,r.kt)("li",{parentName:"ol"},"\u5c06\u5f53\u524d\u8bbe\u5907\u4ece kni_net \u94fe\u8868\u4e2d\u79fb\u9664"),(0,r.kt)("li",{parentName:"ol"},"\u91ca\u653e\u5b8c\u6210\u540e\uff0c\u91ca\u653e\u83b7\u53d6\u5230\u7684 kni_list_lock \u4fe1\u53f7\u91cf")),(0,r.kt)("p",null,"kni_dev_remove \u4e0e kni_ioctl_create \u6709\u76f8\u540c\u4e4b\u5904\uff0c\u5b83\u9996\u5148\u5339\u914d\u9a71\u52a8\uff0c\u5339\u914d\u5230\u540e\u5219\u8c03\u7528\u7f51\u5361\u7684 xx_kni_remove \u51fd\u6570\u6765\u91ca\u653e xx_kni_probe \u51fd\u6570\u4e2d\u521b\u5efa\u7684\u76f8\u5173\u6570\u636e\u7ed3\u6784\uff0c\u6b64\u540e\u5f53 kni \u8bbe\u5907\u4e2d net_dev \u5b58\u5728\u65f6\uff0cunregister net_dev \u5e76\u91ca\u653e\u6b64\u7ed3\u6784\u3002"),(0,r.kt)("p",null,"kni_dev_remove \u4ee3\u7801\u5982\u4e0b\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"347 static int\n348 kni_dev_remove(struct kni_dev *dev)\n349 {\n350     if (!dev)\n351         return -ENODEV;\n352 \n353     switch (dev->device_id) {\n354     #define RTE_PCI_DEV_ID_DECL_IGB(vend, dev) case (dev):\n355     #include <rte_pci_dev_ids.h>\n356         igb_kni_remove(dev->pci_dev);\n357         break;\n358     #define RTE_PCI_DEV_ID_DECL_IXGBE(vend, dev) case (dev):\n359     #include <rte_pci_dev_ids.h>\n360         ixgbe_kni_remove(dev->pci_dev);\n361         break;\n362     default:\n363         break;\n364     }\n365 \n366     if (dev->net_dev) {\n367         unregister_netdev(dev->net_dev);\n368         free_netdev(dev->net_dev);\n369     }\n370 \n371     return 0;\n372 }\n")),(0,r.kt)("p",null,"\u5728\u6267\u884c\u4e86\u4e0a\u8ff0\u8fc7\u7a0b\u540e\uff0c\u7a0b\u5e8f\u901a\u8fc7 close /dev/kni \u6765\u91ca\u653e kni \u8bbe\u5907\u6587\u4ef6\uff0c\u6b64\u8fc7\u7a0b\u5728\u5185\u6838\u4e2d\u901a\u8fc7\u8c03\u7528 kni_release \u51fd\u6570\u6765\u5b8c\u6210\uff0c\u5176\u4ee3\u7801\u5982\u4e0b\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'254 static int\n255 kni_release(struct inode *inode, struct file *file)\n256 {\n257     struct net *net = file->private_data;\n258     struct kni_net *knet = net_generic(net, kni_net_id);\n259     struct kni_dev *dev, *n;\n260 \n261     /* Stop kernel thread for single mode */\n262     if (multiple_kthread_on == 0) {\n263         /* Stop kernel thread */\n264         kthread_stop(knet->kni_kthread);\n265         knet->kni_kthread = NULL;\n266     }\n267 \n268     down_write(&knet->kni_list_lock);\n269     list_for_each_entry_safe(dev, n, &knet->kni_list_head, list) {\n270         /* Stop kernel thread for multiple mode */\n271         if (multiple_kthread_on && dev->pthread != NULL) {\n272             kthread_stop(dev->pthread);\n273             dev->pthread = NULL;\n274         }\n275 \n276 #ifdef RTE_KNI_VHOST\n277         kni_vhost_backend_release(dev);\n278 #endif\n279         kni_dev_remove(dev);\n280         list_del(&dev->list);\n281     }\n282     up_write(&knet->kni_list_lock);\n283 \n284     /* Clear the bit of device in use */\n285     clear_bit(KNI_DEV_IN_USE_BIT_NUM, &knet->device_in_use);\n286 \n287     put_net(net);\n288     KNI_PRINT("/dev/kni closed\\n");\n289 \n290     return 0;\n291 }\n')),(0,r.kt)("p",null,"\u5176\u8fc7\u7a0b\u7c7b\u4f3c kni_ioctl_release\uff0c\u5374\u589e\u52a0\u4e86\u5bf9 kni_net \u4e2d\u521b\u5efa\u7684\u5185\u6838\u7ebf\u7a0b\u7684\u91ca\u653e\u8fc7\u7a0b\uff0c\u5e76\u5c06 kni_net \u4e2d\u7684 device_in_use \u7f6e\u4f4d\uff0c\u8868\u660e\u8bbe\u5907\u7a7a\u95f2\uff0c\u7136\u540e\u8c03\u7528 put_net \u9012\u51cf net \u7ed3\u6784\u7684\u5f15\u7528\u8ba1\u6570\uff0c\u6253\u5370\u4fe1\u606f\u540e\u9000\u51fa\u3002"),(0,r.kt)("h2",{id:"\u4e3a\u4ec0\u4e48-dpdk-\u7a0b\u5e8f\u88ab\u5f3a\u5236\u6740\u6b7b\u7684\u65f6\u5019-kni-\u63a5\u53e3\u88ab\u91ca\u653e"},"\u4e3a\u4ec0\u4e48 dpdk \u7a0b\u5e8f\u88ab\u5f3a\u5236\u6740\u6b7b\u7684\u65f6\u5019 kni \u63a5\u53e3\u88ab\u91ca\u653e\uff1f"),(0,r.kt)("p",null,"\u5f53 dpdk \u7a0b\u5e8f\u88ab\u5f3a\u5236\u6740\u6b7b\u65f6\uff0c\u5185\u6838\u4f1a\u56de\u6536\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u8c03\u7528 kni_release \u6765\u91ca\u653e kni \u865a\u62df\u7f51\u5361\u8bbe\u5907\u3002"),(0,r.kt)("h2",{id:"rte_kni-\u6a21\u5757\u7684\u89e3\u521d\u59cb\u5316\u51fd\u6570"},"rte_kni \u6a21\u5757\u7684\u89e3\u521d\u59cb\u5316\u51fd\u6570"),(0,r.kt)("p",null,"rte_kni \u6a21\u5757\u7684\u89e3\u521d\u59cb\u5316\u51fd\u6570\u4e3a kni_exit\uff0c\u6b64\u51fd\u6570\u4e2d\u9996\u5148\u89e3\u9664 kni misc \u8bbe\u5907\u6ce8\u518c\u4fe1\u606f\uff0c\u7136\u540e\u89e3\u9664\u6ce8\u518c\u7684\u6bcf\u7f51\u7edc\u547d\u4ee4\u7a7a\u95f4\u7684 kni_net_ops \u64cd\u4f5c\u3002"),(0,r.kt)("p",null,"\u5176\u4ee3\u7801\u5982\u4e0b\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'197 static void __exit\n198 kni_exit(void)                                                                                                                                                           \n199 {\n200     misc_deregister(&kni_misc);\n201 #if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 32)\n202     unregister_pernet_subsys(&kni_net_ops);\n203 #else\n204     register_pernet_gen_subsys(&kni_net_id, &kni_net_ops);\n205 #endif /* LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 32) */\n206     KNI_PRINT("####### DPDK kni module unloaded  #######\\n");\n207 }\n')))}p.isMDXComponent=!0}}]);